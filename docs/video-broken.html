<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Underground Tekno - Visual System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            cursor: none;
        }

        #visualizer-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #0F0;
            font-size: 14px;
            text-shadow: 0 0 10px #0F0;
            font-weight: bold;
            pointer-events: none;
        }

        .line {
            margin: 5px 0;
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #0F0;
            font-size: 12px;
            text-align: right;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <canvas id="visualizer-canvas"></canvas>
    <audio id="audio" crossorigin="anonymous"></audio>
    
    <div id="controls">
        <div class="line">[ FREE UNDERGROUND TEKNO ]</div>
        <div class="line">STATUS: <span id="status">READY</span></div>
        <div class="line">VISUAL: <span id="visual-name">---</span></div>
        <div class="line">VOLUME: <span id="volume">80</span>%</div>
        <div class="line">FREQ: <span id="freq-count">0</span></div>
    </div>

    <div id="info-panel">
        SPACE: play/pause | ‚Üê/‚Üí: change visual<br>
        ‚Üë/‚Üì: volume | F: fullscreen | I: toggle info
    </div>

    <script>
        'use strict';

        // === CORE SETUP ===
        const canvas = document.getElementById('visualizer-canvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audio');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // === AUDIO SETUP ===
        let audioContext, analyser, dataArray, isPlaying = false;
        
        audio.src = 'https://radio.freeundergroundtekno.org/listen/free_underground_tekno/radio.mp3';
        audio.volume = 0.8;
        audio.crossOrigin = 'anonymous';
        audio.autoplay = true;

        function initAudio() {
            if (audioContext) return;
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }
        
        function startAutoplay() {
            if (!audioContext) initAudio();
            
            audio.play().then(() => {
                isPlaying = true;
                document.getElementById('status').textContent = 'PLAYING';
                requestAnimationFrame(animate);
            }).catch(err => {
                console.log('Autoplay blocked, click to start');
                document.getElementById('status').textContent = 'CLICK TO START';
            });
        }

        function togglePlay() {
            if (!audioContext) initAudio();
            
            if (isPlaying) {
                audio.pause();
                isPlaying = false;
                document.getElementById('status').textContent = 'PAUSED';
            } else {
                audio.play().catch(err => console.error('Play error:', err));
                isPlaying = true;
                document.getElementById('status').textContent = 'PLAYING';
                requestAnimationFrame(animate);
            }
        }

        // === AUDIO ANALYSIS HELPERS ===
        function getAudioData() {
            if (!analyser || !dataArray) return { bass: 0, mid: 0, treble: 0, avg: 0 };
            
            analyser.getByteFrequencyData(dataArray);
            
            const bass = dataArray.slice(0, 50).reduce((a,b) => a+b, 0) / 50 / 255;
            const mid = dataArray.slice(50, 150).reduce((a,b) => a+b, 0) / 100 / 255;
            const treble = dataArray.slice(150, 250).reduce((a,b) => a+b, 0) / 100 / 255;
            const avg = dataArray.reduce((a,b) => a+b, 0) / dataArray.length / 255;
            
            return { bass, mid, treble, avg };
        }

        // === VISUALIZER BASE CLASS ===
        class Visualizer {
            constructor(name) {
                this.name = name;
                this.time = 0;
            }
            
            reset() {
                this.time = 0;
            }
            
            draw(audio) {
                // Override in subclasses
            }
        }

        // === OSCILLOSCOPE RAVE VISUALIZER ===
        class OscilloscopeRave extends Visualizer {
            constructor() {
                super('OSCILLOSCOPE_RAVE');
            }
            
            draw(audio) {
                ctx.fillStyle = 'rgba(0, 5, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.time += 0.02 + audio.bass * 0.03;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Grid
                ctx.strokeStyle = 'rgba(0, 255, 100, 0.2)';
                ctx.lineWidth = 1;
                const gridSize = 40;
                
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Waveforms
                for (let layer = 0; layer < 3; layer++) {
                    const hue = (layer * 120 + this.time * 20) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${0.8 - layer * 0.2})`;
                    ctx.lineWidth = 2 + layer;
                    ctx.beginPath();
                    
                    for (let i = 0; i < dataArray.length; i++) {
                        const x = (i / dataArray.length) * canvas.width;
                        const y = centerY + (dataArray[i] - 128) * (1 + audio.bass + layer * 0.5);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Frequency rays
                const numRays = 32;
                for (let i = 0; i < numRays; i++) {
                    const angle = (i / numRays) * Math.PI * 2;
                    const level = dataArray[i * 8] / 255;
                    
                    if (level > 0.3) {
                        const length = level * 200;
                        const hue = (i * 11 + this.time * 30) % 360;
                        
                        ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${level})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            centerX + Math.cos(angle) * length,
                            centerY + Math.sin(angle) * length
                        );
                        ctx.stroke();
                    }
                }
                
                // Center pulse
                const coreSize = 30 + audio.bass * 80;
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${audio.bass * 0.9})`);
                coreGradient.addColorStop(0.5, `rgba(0, 255, 100, ${audio.mid * 0.7})`);
                coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Flash
                if (audio.bass > 0.88) {
                    ctx.fillStyle = `rgba(0, 255, 100, ${(audio.bass - 0.88) * 3})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        // === BASS PULSE VISUALIZER ===
        class BassPulse extends Visualizer {
            constructor() {
                super('BASS_PULSE');
                this.particles = [];
                this.maxParticles = 50; // Reduced from 150
            }
            
            reset() {
                super.reset();
                this.particles = [];
            }
            
            draw(audio) {
                ctx.fillStyle = 'rgba(0, 0, 10, 0.15)'; // Stronger fade
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.time += 0.02 + audio.bass * 0.05;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Rings
                for (let i = 0; i < 8; i++) { // Reduced from 10
                    const radius = 50 + i * 70 + Math.sin(this.time - i * 0.3) * audio.bass * 100;
                    const hue = (i * 45 + this.time * 30) % 360;
                    const alpha = (1 - i / 8) * (0.5 + audio.bass * 0.5);
                    
                    ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                    ctx.lineWidth = 2 + audio.bass * 5;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Spikes
                const numSpikes = 48; // Reduced from 64
                for (let i = 0; i < numSpikes; i++) {
                    const angle = (i / numSpikes) * Math.PI * 2;
                    const dataIdx = Math.min(Math.floor(i * 5), dataArray.length - 1);
                    const level = dataArray[dataIdx] / 255;
                    
                    if (level > 0.25) {
                        const length = level * 200;
                        const hue = (i * 8 + this.time * 40) % 360;
                        
                        const x1 = centerX + Math.cos(angle) * 100;
                        const y1 = centerY + Math.sin(angle) * 100;
                        const x2 = centerX + Math.cos(angle) * (100 + length);
                        const y2 = centerY + Math.sin(angle) * (100 + length);
                        
                        ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${level * 0.8})`;
                        ctx.lineWidth = 2 + level * 3;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                // Particles - simplified
                if (audio.bass > 0.75 && this.particles.length < this.maxParticles && Math.random() > 0.85) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + audio.bass * 5;
                    this.particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        hue: (this.time * 50) % 360
                    });
                }
                
                // Clean old particles first
                this.particles = this.particles.filter(p => p.life > 0);
                
                // Update and draw
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.025; // Faster decay
                    
                    if (p.life > 0) {
                        ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Core
                const coreSize = 50 + audio.bass * 80;
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${audio.bass * 0.9})`);
                coreGradient.addColorStop(0.5, `rgba(150, 100, 255, ${audio.mid * 0.7})`);
                coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Flash
                if (audio.bass > 0.9) {
                    ctx.fillStyle = `rgba(255, 100, 255, ${(audio.bass - 0.9) * 2})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        // === RAVE LANDSCAPE VISUALIZER ===
        class RaveLandscape extends Visualizer {
            constructor() {
                super('RAVE_LANDSCAPE');
                this.structures = [];
                this.initStructures();
            }
            
            initStructures() {
                const types = ['speaker', 'tower', 'stack'];
                for (let i = 0; i < 12; i++) {
                    this.structures.push({
                        x: (i / 12) * canvas.width + canvas.width * 0.05,
                        type: types[Math.floor(Math.random() * types.length)],
                        height: 100 + Math.random() * 200,
                        width: 40 + Math.random() * 60
                    });
                }
            }
            
            reset() {
                super.reset();
                this.structures = [];
                this.initStructures();
            }
            
            draw(audio) {
                ctx.fillStyle = 'rgba(0, 0, 20, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.time += 0.02;
                
                const horizon = canvas.height * 0.7;
                
                // Ground
                const groundGradient = ctx.createLinearGradient(0, horizon, 0, canvas.height);
                groundGradient.addColorStop(0, 'rgba(20, 0, 40, 0.8)');
                groundGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, horizon, canvas.width, canvas.height - horizon);
                
                // Structures
                this.structures.forEach((s, i) => {
                    const dataIdx = (i * 20) % 256;
                    const level = dataArray[dataIdx] / 255;
                    const hue = (i * 30 + this.time * 20) % 360;
                    
                    const y = horizon - s.height * (1 + audio.bass * 0.3);
                    const width = s.width * (1 + level * 0.2);
                    
                    // Structure body
                    ctx.strokeStyle = `hsla(${hue}, 80%, 50%, ${0.6 + level * 0.4})`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(s.x - width/2, y, width, s.height * (1 + audio.bass * 0.3));
                    
                    // Speaker cone
                    if (s.type === 'speaker') {
                        const coneSize = width * 0.4 * (1 + level * 0.5);
                        ctx.fillStyle = `hsla(${hue}, 90%, 60%, ${0.5 + level * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(s.x, y + s.height * 0.5, coneSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Level indicator
                    if (level > 0.5) {
                        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${level})`;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
                        ctx.strokeRect(s.x - width/2, y, width, s.height * (1 + audio.bass * 0.3));
                        ctx.shadowBlur = 0;
                    }
                });
                
                // Lasers
                if (audio.treble > 0.6) {
                    for (let i = 0; i < 4; i++) {
                        const x = (i / 4) * canvas.width;
                        const hue = (i * 90 + this.time * 50) % 360;
                        
                        ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${audio.treble * 0.6})`;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x + Math.sin(this.time + i) * 100, horizon);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Bass flash
                if (audio.bass > 0.85) {
                    ctx.fillStyle = `rgba(255, 0, 255, ${(audio.bass - 0.85) * 2})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        // === COSMIC JOURNEY (SECRET) ===
        class CosmicJourney extends Visualizer {
            constructor() {
                super('??? COSMIC_JOURNEY ???');
                this.stars = [];
                this.initStars();
            }
            
            initStars() {
                for (let i = 0; i < 200; i++) {
                    this.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        z: Math.random() * 2000,
                        size: Math.random() * 2
                    });
                }
            }
            
            reset() {
                super.reset();
                this.stars = [];
                this.initStars();
            }
            
            draw(audio) {
                ctx.fillStyle = 'rgba(0, 0, 10, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.time += 0.01 + audio.bass * 0.02;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Starfield
                this.stars.forEach(star => {
                    star.z -= 5 + audio.bass * 15;
                    
                    if (star.z <= 0) {
                        star.z = 2000;
                        star.x = Math.random() * canvas.width;
                        star.y = Math.random() * canvas.height;
                    }
                    
                    const scale = 1000 / star.z;
                    const x = (star.x - centerX) * scale + centerX;
                    const y = (star.y - centerY) * scale + centerY;
                    const size = star.size * scale;
                    
                    if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
                        ctx.fillStyle = `rgba(200, 220, 255, ${Math.min(1, scale)})`;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Spiral galaxy
                for (let s = 0; s < 2; s++) {
                    ctx.strokeStyle = `hsla(${(this.time * 30 + s * 180) % 360}, 80%, 60%, 0.3)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < 100; i++) {
                        const t = i / 100;
                        const angle = s * Math.PI + t * Math.PI * 6 + this.time * 0.5;
                        const radius = 100 + t * 500;
                        
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Sun
                const sunSize = 40 + audio.bass * 30;
                const sunGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, sunSize);
                sunGradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
                sunGradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.8)');
                sunGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                
                ctx.fillStyle = sunGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, sunSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Planets
                const numPlanets = 5;
                for (let i = 0; i < numPlanets; i++) {
                    const angle = (i / numPlanets) * Math.PI * 2 + this.time * (1 - i * 0.15);
                    const orbit = 120 + i * 80;
                    const size = 8 + i * 3;
                    const hue = (i * 72) % 360;
                    
                    const x = centerX + Math.cos(angle) * orbit;
                    const y = centerY + Math.sin(angle) * orbit;
                    
                    ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Orbit path
                    ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.2)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, orbit, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Wormhole
                if (audio.bass > 0.75) {
                    for (let r = 0; r < 10; r++) {
                        const radius = (r / 10) * 200 + audio.bass * 150;
                        const hue = (r * 36 + this.time * 100) % 360;
                        
                        ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${(1 - r/10) * audio.bass})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Flash
                if (audio.bass > 0.9) {
                    ctx.fillStyle = `rgba(100, 200, 255, ${(audio.bass - 0.9) * 3})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        // === VISUALIZER MANAGER ===
        const visualizers = [
            new OscilloscopeRave(),
            new BassPulse(),
            new RaveLandscape()
        ];
        
        let currentVisualizer = 0;
        let secretUnlocked = false;
        let keySequence = '';

        function updateVisualizerName() {
            document.getElementById('visual-name').textContent = visualizers[currentVisualizer].name;
        }

        // === SECRET CODE ===
        document.addEventListener('keypress', (e) => {
            keySequence += e.key.toLowerCase();
            if (keySequence.length > 10) {
                keySequence = keySequence.slice(-10);
            }
            
            if (keySequence.includes('freetekno') && !secretUnlocked) {
                secretUnlocked = true;
                visualizers.push(new CosmicJourney());
                currentVisualizer = visualizers.length - 1;
                updateVisualizerName();
                
                canvas.style.border = '5px solid #0FF';
                setTimeout(() => canvas.style.border = 'none', 300);
                
                console.log('üåå SECRET UNLOCKED! ü™ê');
            }
        });

        // === ANIMATION LOOP ===
        function animate() {
            if (!isPlaying) return;
            
            const audio = getAudioData();
            
            // Update freq counter
            document.getElementById('freq-count').textContent = Math.floor(audio.avg * 1000);
            
            // Draw current visualizer
            visualizers[currentVisualizer].draw(audio);
            
            requestAnimationFrame(animate);
        }

        // === CONTROLS ===
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePlay();
                    break;
                    
                case 'ArrowLeft':
                    currentVisualizer = (currentVisualizer - 1 + visualizers.length) % visualizers.length;
                    visualizers[currentVisualizer].reset();
                    updateVisualizerName();
                    break;
                    
                case 'ArrowRight':
                    currentVisualizer = (currentVisualizer + 1) % visualizers.length;
                    visualizers[currentVisualizer].reset();
                    updateVisualizerName();
                    break;
                    
                case 'ArrowUp':
                    audio.volume = Math.min(1, audio.volume + 0.1);
                    document.getElementById('volume').textContent = Math.floor(audio.volume * 100);
                    break;
                    
                case 'ArrowDown':
                    audio.volume = Math.max(0, audio.volume - 0.1);
                    document.getElementById('volume').textContent = Math.floor(audio.volume * 100);
                    break;
                    
                case 'KeyF':
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                    break;
                    
                case 'KeyI':
                    const info = document.getElementById('info-panel');
                    info.style.display = info.style.display === 'none' ? 'block' : 'none';
                    break;
            }
        });

        // Click to play
        canvas.addEventListener('click', togglePlay);

        // Initialize and Autoplay
        updateVisualizerName();
        
        // Start autoplay after page load
        window.addEventListener('load', () => {
            setTimeout(startAutoplay, 500);
        });
        
        console.log('üéß Free Underground Tekno - Visual System Ready');
        console.log('üí° Try typing "freetekno" for a secret...');
    </script>
</body>
</html>
