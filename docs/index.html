<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FREE UNDERGROUND TEKNO - Live Radio VJ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        /* BACKGROUND IMAGE - con effetti 3D e motion blur */
        #background {
            position: fixed;
            width: 100vw;
            height: 100vh;
            background-image: url('./freetekno.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 0;
            transition: transform 0.05s ease-out, filter 0.1s ease-out;
            transform-origin: center center;
            will-change: transform, filter;
        }
        
        /* Zoom burst effect SOTTOCASSA - PI√ô POTENTE! */
        body.zoom-burst #background {
            animation: zoom-burst 0.3s ease-out;
        }
        
        @keyframes zoom-burst {
            0% { 
                transform: scale(1);
                filter: blur(0);
            }
            50% { 
                transform: scale(1.35); /* da 1.15 a 1.35! */
                filter: blur(12px); /* da 8px a 12px! */
            }
            100% { 
                transform: scale(1);
                filter: blur(0);
            }
        }
        
        /* Rapid shake */
        body.shake-burst #background {
            animation: shake-burst 0.2s ease-out;
        }
        
        @keyframes shake-burst {
            0%, 100% { transform: translate(0, 0) scale(1); }
            20% { transform: translate(-10px, 5px) scale(1.05) rotate(2deg); }
            40% { transform: translate(10px, -5px) scale(0.98) rotate(-2deg); }
            60% { transform: translate(-8px, -5px) scale(1.03) rotate(1deg); }
            80% { transform: translate(8px, 5px) scale(0.99) rotate(-1deg); }
        }
        
        /* Psychedelic states */
        body.trip-mode #background {
            animation: breathe 4s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(2deg); }
        }
        
        body.khole-mode #background {
            filter: blur(3px) contrast(1.5) saturate(0);
            animation: khole-drift 8s ease-in-out infinite;
        }
        
        @keyframes khole-drift {
            0%, 100% { transform: scale(1) translateY(0); }
            25% { transform: scale(1.05) translateY(-20px) rotate(1deg); }
            75% { transform: scale(0.95) translateY(20px) rotate(-1deg); }
        }
        
        /* STROBE OVERLAY - flash bianco */
        #strobeFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            z-index: 999;
            pointer-events: none;
        }
        
        /* GEOMETRIC STROBES - flash geometrici che seguono il disegno */
        .geo-strobe {
            position: fixed;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.05s;
        }
        
        /* Strobes laterali (sound system walls) */
        .geo-strobe.left-wall {
            left: 0;
            top: 0;
            width: 25%;
            height: 100%;
            background: linear-gradient(to right, rgba(255,255,255,0.9), transparent);
        }
        
        .geo-strobe.right-wall {
            right: 0;
            top: 0;
            width: 25%;
            height: 100%;
            background: linear-gradient(to left, rgba(255,255,255,0.9), transparent);
        }
        
        /* Strobes cerchi (seguono i cerchi concentrici) */
        .geo-strobe.circle-ring {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            background: transparent;
        }
        
        /* Strobes orizzontali (crowd/stage) */
        .geo-strobe.horizontal-bottom {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, rgba(255,255,255,0.9), transparent);
        }
        
        .geo-strobe.horizontal-top {
            top: 0;
            left: 0;
            width: 100%;
            height: 20%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }
        
        /* Strobes radiali dal centro */
        .geo-strobe.radial-burst {
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            transform: translate(-50%, -50%);
            background: radial-gradient(
                circle at center,
                transparent 20%,
                rgba(255,255,255,0.8) 40%,
                transparent 60%
            );
        }
        
        /* PULSE EFFECT - cerchi molto pi√π visibili */
        #circlePulse {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 5px solid rgba(255, 255, 255, 0.9);
            z-index: 1;
            pointer-events: none;
            box-shadow: 
                0 0 30px rgba(255, 255, 255, 0.8),
                0 0 60px rgba(255, 255, 255, 0.6),
                inset 0 0 30px rgba(255, 255, 255, 0.4);
        }
        
        /* SPEAKER FLASHES - flash sulle casse laterali */
        .speaker-flash {
            position: fixed;
            width: 150px;
            height: 400px;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, transparent 70%);
            opacity: 0;
            pointer-events: none;
            z-index: 2;
            filter: blur(30px);
        }
        
        .speaker-flash.left {
            left: 15%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .speaker-flash.right {
            right: 15%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* CROWD STROBES - luci che illuminano la folla */
        #crowdStrobe {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, rgba(255,255,255,0.8), transparent);
            opacity: 0;
            pointer-events: none;
            z-index: 3;
            mix-blend-mode: overlay;
        }
        
        /* ANTENNA BEAMS - raggi dalle antenne centrali */
        .antenna-beam {
            position: fixed;
            top: 30%;
            left: 50%;
            width: 2px;
            height: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,1), transparent);
            transform-origin: top center;
            pointer-events: none;
            z-index: 2;
            opacity: 0;
        }
        
        .antenna-beam.left {
            margin-left: -100px;
        }
        
        .antenna-beam.center {
            margin-left: 0;
        }
        
        .antenna-beam.right {
            margin-left: 100px;
        }
        
        /* VORTEX ROTATION - rotazione cerchi pi√π visibile */
        #vortexRotation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            mix-blend-mode: screen;
            opacity: 0.6;
        }
        
        /* TUNNEL EFFECT - zoom 3D verso centro */
        #tunnelEffect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            perspective: 1000px;
        }
        
        .tunnel-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: tunnel-zoom 3s linear infinite;
        }
        
        @keyframes tunnel-zoom {
            0% {
                width: 50px;
                height: 50px;
                opacity: 0;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                width: 2000px;
                height: 2000px;
                opacity: 0;
            }
        }
        
        /* GRAIN OVERLAY - rumore analogico */
        #grainOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23noise)" opacity="0.4"/></svg>');
            opacity: 0.15;
            z-index: 100;
            pointer-events: none;
            animation: grain-move 0.5s steps(4) infinite;
        }
        
        @keyframes grain-move {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }
        
        /* VHS GLITCH LINES */
        #vhsLines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 101;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .vhs-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            animation: vhs-scan 8s linear infinite;
        }
        
        @keyframes vhs-scan {
            0% { top: -2px; }
            100% { top: 100%; }
        }
        
        /* CHROMATIC ABERRATION */
        body.aberration-mode #background {
            animation: chromatic-shift 0.3s ease-in-out infinite;
        }
        
        @keyframes chromatic-shift {
            0%, 100% { 
                filter: none;
            }
            50% { 
                filter: 
                    drop-shadow(2px 0 0 rgba(255,0,0,0.5))
                    drop-shadow(-2px 0 0 rgba(0,255,255,0.5));
            }
        }
        
        /* SCANLINES - effetto CRT */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 102;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0) 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            opacity: 0.3;
        }
        
        /* VIGNETTE - bordi scuri */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 103;
            pointer-events: none;
            background: radial-gradient(
                ellipse at center,
                transparent 30%,
                rgba(0, 0, 0, 0.4) 80%,
                rgba(0, 0, 0, 0.8) 100%
            );
        }
        
        /* DUST PARTICLES - polvere sullo schermo */
        .dust-particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 104;
            pointer-events: none;
            animation: dust-float 20s linear infinite;
        }
        
        @keyframes dust-float {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.5;
            }
            90% {
                opacity: 0.5;
            }
            100% {
                transform: translate(var(--dust-x), var(--dust-y)) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* FREQUENCY VISUALIZER - barre frequenze in basso - DISABILITATO */
        #frequencyViz {
            display: none;
        }
        
        .freq-bar {
            width: 8px;
            background: linear-gradient(to top, #fff, #888);
            opacity: 0.8;
            transition: height 0.05s;
        }
        
        /* üåÄ DISTORTION ZONES - distorsioni parziali graduali */
        .distortion-zone {
            position: fixed;
            pointer-events: none;
            z-index: 50;
            mix-blend-mode: screen;
            opacity: 0;
            transition: opacity 0.1s ease-out, transform 0.2s ease-out;
        }
        
        .distortion-zone.active {
            animation: distort-pulse 0.4s ease-out;
        }
        
        @keyframes distort-pulse {
            0% { 
                opacity: 0;
                transform: scale(0.8);
                filter: blur(10px) hue-rotate(0deg);
            }
            50% { 
                opacity: 0.8;
                transform: scale(1.2);
                filter: blur(5px) hue-rotate(180deg);
            }
            100% { 
                opacity: 0;
                transform: scale(1);
                filter: blur(15px) hue-rotate(360deg);
            }
        }
        
        /* Effetto glitch warp su zone specifiche */
        .warp-zone {
            position: fixed;
            pointer-events: none;
            z-index: 51;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(255,0,0,0.3) 25%,
                rgba(0,255,255,0.3) 50%,
                rgba(255,0,255,0.3) 75%,
                transparent 100%
            );
            opacity: 0;
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
        }
        
        .warp-zone.active {
            animation: warp-glitch 0.3s steps(3) infinite;
        }
        
        @keyframes warp-glitch {
            0% { 
                opacity: 0.6;
                transform: translateX(0) skewX(0deg);
                filter: hue-rotate(0deg);
            }
            33% { 
                opacity: 0.8;
                transform: translateX(-5px) skewX(5deg);
                filter: hue-rotate(120deg);
            }
            66% { 
                opacity: 0.7;
                transform: translateX(5px) skewX(-5deg);
                filter: hue-rotate(240deg);
            }
            100% { 
                opacity: 0.6;
                transform: translateX(0) skewX(0deg);
                filter: hue-rotate(360deg);
            }
        }
        
        /* Chromatic split su zone specifiche */
        .chroma-zone {
            position: fixed;
            pointer-events: none;
            z-index: 52;
            background: radial-gradient(
                circle at center,
                rgba(255,0,0,0.4) 0%,
                transparent 50%
            );
            opacity: 0;
            mix-blend-mode: screen;
        }
        
        .chroma-zone.active {
            animation: chroma-split 0.2s ease-out;
        }
        
        @keyframes chroma-split {
            0% { 
                opacity: 0;
                transform: translate(0, 0);
            }
            25% { 
                opacity: 0.9;
                transform: translate(-3px, 0);
                filter: drop-shadow(6px 0 0 cyan) drop-shadow(-6px 0 0 red);
            }
            75% { 
                opacity: 0.7;
                transform: translate(3px, 0);
                filter: drop-shadow(-4px 0 0 cyan) drop-shadow(4px 0 0 red);
            }
            100% { 
                opacity: 0;
                transform: translate(0, 0);
            }
        }

        
        /* üí´ SUPER SPATIAL GLOW STROBO - effetto strobo spaziale con glow */
        #spatialStrobo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            mix-blend-mode: screen;
            transition: opacity 0.05s linear;
        }
        
        /* Pattern 1: Radial explosion */
        #spatialStrobo.radial-explosion {
            background: radial-gradient(
                circle at center,
                rgba(255, 255, 255, 1) 0%,
                var(--glow-color, rgba(255, 0, 255, 0.8)) 30%,
                transparent 60%
            );
            filter: blur(20px);
        }
        
        /* Pattern 2: Cross beam */
        #spatialStrobo.cross-beam {
            background: 
                linear-gradient(to bottom, transparent 48%, var(--glow-color, rgba(0, 255, 255, 0.9)) 50%, transparent 52%),
                linear-gradient(to right, transparent 48%, var(--glow-color, rgba(0, 255, 255, 0.9)) 50%, transparent 52%);
            filter: blur(15px);
        }
        
        /* Pattern 3: Diamond burst */
        #spatialStrobo.diamond-burst {
            background: conic-gradient(
                from 45deg at center,
                transparent 0deg,
                var(--glow-color, rgba(255, 255, 0, 0.9)) 90deg,
                transparent 180deg,
                var(--glow-color, rgba(255, 255, 0, 0.9)) 270deg,
                transparent 360deg
            );
            filter: blur(25px);
        }
        
        /* Pattern 4: Spiral glow */
        #spatialStrobo.spiral-glow {
            background: conic-gradient(
                from 0deg at center,
                var(--glow-color, rgba(0, 255, 0, 0.0)) 0deg,
                var(--glow-color, rgba(0, 255, 0, 0.9)) 60deg,
                var(--glow-color, rgba(0, 255, 0, 0.0)) 120deg,
                var(--glow-color, rgba(0, 255, 0, 0.9)) 180deg,
                var(--glow-color, rgba(0, 255, 0, 0.0)) 240deg,
                var(--glow-color, rgba(0, 255, 0, 0.9)) 300deg,
                var(--glow-color, rgba(0, 255, 0, 0.0)) 360deg
            );
            filter: blur(30px);
            animation: rotate-strobo 0.3s linear infinite;
        }
        
        /* Pattern 5: Ring pulse */
        #spatialStrobo.ring-pulse {
            background: radial-gradient(
                circle at center,
                transparent 30%,
                var(--glow-color, rgba(255, 0, 0, 0.9)) 40%,
                transparent 50%,
                var(--glow-color, rgba(255, 0, 0, 0.7)) 60%,
                transparent 70%
            );
            filter: blur(10px);
            animation: pulse-scale 0.2s ease-out infinite;
        }
        
        @keyframes rotate-strobo {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        @keyframes pulse-scale {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        /* ‚ú® SILVER GLOW PARTICLES - particelle glow argentate stroboscopiche */
        .silver-glow-particle {
            position: fixed;
            pointer-events: none;
            z-index: 40;
            border-radius: 50%;
            opacity: 0;
            filter: blur(8px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.9),
                        0 0 40px rgba(200, 200, 255, 0.6),
                        0 0 60px rgba(150, 150, 255, 0.4);
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(200, 200, 255, 0.5) 50%, transparent 70%);
        }

        .silver-glow-particle.active {
            animation: glow-pulse 0.6s ease-out forwards;
        }

        @keyframes glow-pulse {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            40% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(1.8);
            }
        }

        /* üåÄ SPIRAL WHIRL - effetti spiraloidi rotativi */
        .spiral-whirl {
            position: fixed;
            pointer-events: none;
            z-index: 35;
            opacity: 0;
        }

        .spiral-whirl.active {
            animation: whirl-spin 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes whirl-spin {
            0% {
                opacity: 0;
                transform: scale(0.2) rotate(0deg);
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(1.5) rotate(720deg);
            }
        }

        /* ‚ú® SHIMMER TWINKLE - effetto scintillio */
        .shimmer-twinkle {
            position: fixed;
            pointer-events: none;
            z-index: 38;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            opacity: 0;
            box-shadow: 0 0 15px rgba(200, 220, 255, 0.9);
        }

        .shimmer-twinkle.active {
            animation: twinkle-flash 0.4s ease-out forwards;
        }

        @keyframes twinkle-flash {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(3);
            }
        }

        /* üåÄ LOCALIZED SPIRAL ZOOM - zoom spirale localizzati */
        .spiral-vortex {
            position: fixed;
            pointer-events: none;
            z-index: 60;
            opacity: 0;
            mix-blend-mode: screen;
            border-radius: 50%;
            transition: opacity 0.1s ease-out;
        }
        
        .spiral-vortex.active {
            animation: spiral-zoom-in 0.8s ease-out forwards;
        }
        
        @keyframes spiral-zoom-in {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3) rotate(0deg);
                filter: blur(20px);
            }
            30% {
                opacity: 0.9;
                transform: translate(-50%, -50%) scale(1.5) rotate(180deg);
                filter: blur(5px);
            }
            70% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(2.2) rotate(360deg);
                filter: blur(10px);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3) rotate(540deg);
                filter: blur(25px);
            }
        }
        
        /* Variante: spirale che si contrae (implode) */
        .spiral-vortex.implode {
            animation: spiral-implode 0.6s ease-in forwards;
        }
        
        @keyframes spiral-implode {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3) rotate(540deg);
                filter: blur(25px);
            }
            40% {
                opacity: 0.9;
                transform: translate(-50%, -50%) scale(1.5) rotate(270deg);
                filter: blur(5px);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.2) rotate(0deg);
                filter: blur(15px);
            }
        }
        
        /* Variante: spirale pulsante */
        .spiral-vortex.pulse {
            animation: spiral-pulse 0.5s ease-in-out forwards;
        }
        
        @keyframes spiral-pulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8) rotate(0deg);
            }
            25% {
                opacity: 0.9;
                transform: translate(-50%, -50%) scale(1.8) rotate(90deg);
                filter: blur(3px);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
                filter: blur(8px);
            }
            75% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1.6) rotate(270deg);
                filter: blur(5px);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(2.5) rotate(360deg);
                filter: blur(20px);
            }
        }
        
        /* ‚ö´‚ö™ NEGATIVE LAYER - effetto negativo con raggi rotativi */
        #negativeLayer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            mix-blend-mode: difference; /* effetto negativo/inverso */
            transition: opacity 0.05s linear;
        }
        
        /* Raggi rotativi dal centro */
        .rotating-rays {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200vw;
            height: 200vw;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.05s linear;
        }
        
        .rotating-rays.active {
            animation: rotate-rays-fast 0.3s linear infinite;
        }
        
        @keyframes rotate-rays-fast {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        /* Pattern 1: Raggi singoli bianchi */
        .rotating-rays.single-beam {
            background: conic-gradient(
                from 0deg at center,
                transparent 0deg,
                white 2deg,
                transparent 4deg,
                transparent 180deg,
                white 182deg,
                transparent 184deg,
                transparent 360deg
            );
            filter: blur(2px) drop-shadow(0 0 20px white);
        }
        
        /* Pattern 2: Raggi multipli (8 raggi) */
        .rotating-rays.multi-beam {
            background: conic-gradient(
                from 0deg at center,
                white 0deg, transparent 5deg,
                white 45deg, transparent 50deg,
                white 90deg, transparent 95deg,
                white 135deg, transparent 140deg,
                white 180deg, transparent 185deg,
                white 225deg, transparent 230deg,
                white 270deg, transparent 275deg,
                white 315deg, transparent 320deg,
                white 360deg
            );
            filter: blur(3px) drop-shadow(0 0 15px white);
        }
        
        /* Pattern 3: Spirale continua */
        .rotating-rays.spiral-beam {
            background: conic-gradient(
                from 0deg at center,
                white 0deg,
                transparent 30deg,
                white 60deg,
                transparent 90deg,
                white 120deg,
                transparent 150deg,
                white 180deg,
                transparent 210deg,
                white 240deg,
                transparent 270deg,
                white 300deg,
                transparent 330deg,
                white 360deg
            );
            filter: blur(4px) drop-shadow(0 0 25px white);
        }
        
        /* Pattern 4: Croce espandente RUOTATA 45¬∞ */
        .rotating-rays.cross-beam {
            background: 
                linear-gradient(135deg, transparent 48%, white 50%, transparent 52%),
                linear-gradient(45deg, transparent 48%, white 50%, transparent 52%);
            filter: blur(5px) drop-shadow(0 0 30px white);
        }
        
        /* Strobo circolari concentrici */
        .circular-strobo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 3px solid white;
            pointer-events: none;
            opacity: 0;
            box-shadow: 0 0 40px white, inset 0 0 40px white;
        }
        
        .circular-strobo.active {
            animation: circle-pulse-expand 0.4s ease-out forwards;
        }
        
        @keyframes circle-pulse-expand {
            0% {
                width: 50px;
                height: 50px;
                opacity: 1;
                border-width: 5px;
            }
            50% {
                opacity: 0.8;
                border-width: 3px;
            }
            100% {
                width: 150vw;
                height: 150vw;
                opacity: 0;
                border-width: 1px;
            }
        }
        
        /* üåä FRACTAL TEARS - distorsioni frattali organiche */
        .fractal-tear {
            position: fixed;
            pointer-events: none;
            z-index: 155;
            opacity: 0;
            mix-blend-mode: difference;
            background: white;
            filter: blur(3px);
        }
        
        .fractal-tear.active {
            animation: tear-distort 0.5s ease-out forwards;
        }
        
        @keyframes tear-distort {
            0% {
                opacity: 0;
                transform: scale(0.5) rotate(0deg);
            }
            40% {
                opacity: 0.9;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }
        
        /* CONTROLS */
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border: 2px solid #fff;
            color: #fff;
            font-size: 12px;
            transition: opacity 0.3s;
        }
        
        #controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* MENU TOGGLE BUTTON - pulsante floating per mostrare menu */
        #menuToggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #fff;
            color: #000;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
        }

        #menuToggle.show {
            opacity: 1;
            pointer-events: auto;
        }

        #menuToggle:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        #menuToggle:active {
            transform: scale(0.95);
        }

        /* MINIMAL PLAY BUTTON - per autoplay fallback */
        #minimalPlay {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #fff;
            color: #000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #minimalPlay.show {
            display: flex;
        }

        #minimalPlay:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.15);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #minimalPlay:active {
            transform: scale(0.95);
        }

        /* üí´ DREAM SOUNDSYSTEM LAYER - blurred memory flashes */
        #dreamLayer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 250;  /* Above effects, below strobes */
            pointer-events: none;
        }

        .dream-image {
            position: fixed;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            z-index: 250;
            pointer-events: none;

            /* Dream effect: heavy blur + glow */
            filter: blur(40px) brightness(1.3) contrast(0.8);
            mix-blend-mode: screen;  /* Light blend for ghostly effect */

            /* Animation: fade in/out like dreaming */
            transition: opacity 0.8s ease-in-out;
        }

        /* Dream appearance state */
        .dream-image.dreaming {
            opacity: 0.5;  /* Semi-transparent like a memory */
        }

        /* Extra blur for more dream effect */
        .dream-image.deep-dream {
            opacity: 0.35;
            filter: blur(60px) brightness(1.5) contrast(0.6) saturate(0.8);
        }

        /* Slightly less blur for occasional clarity */
        .dream-image.lucid-dream {
            opacity: 0.6;
            filter: blur(25px) brightness(1.2) contrast(0.9);
        }

        /* Animation for gentle pulse during appearance */
        @keyframes dream-pulse {
            0% { opacity: 0; filter: blur(50px) brightness(1.0) contrast(0.7); }
            50% { opacity: 0.5; filter: blur(35px) brightness(1.4) contrast(0.8); }
            100% { opacity: 0; filter: blur(60px) brightness(1.0) contrast(0.6); }
        }

        .dream-image.pulse-dream {
            animation: dream-pulse 3s ease-in-out forwards;
        }

        /* Glow effect overlay for additional atmospheric feel */
        @keyframes dream-glow {
            0% { text-shadow: 0 0 0px rgba(255,255,255,0); }
            50% { text-shadow: 0 0 80px rgba(255,255,255,0.8); }
            100% { text-shadow: 0 0 0px rgba(255,255,255,0); }
        }

        .dream-image.glow-dream {
            animation: dream-glow 2.5s ease-in-out infinite;
        }

        /* Su desktop: mostra toggle quando menu nascosto */
        @media (min-width: 769px) {
            #menuToggle.show {
                display: flex;
            }
        }

        /* Su mobile: non mostra toggle */
        @media (max-width: 768px) {
            #menuToggle {
                display: none;
            }
        }

        button {
            background: #fff;
            color: #000;
            border: none;
            padding: 8px 15px;
            margin: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 11px;
            touch-action: manipulation;
            transition: background 0.2s;
        }

        button:hover {
            background: #ccc;
        }

        button:active {
            background: #999;
            transform: scale(0.98);
        }

        /* Aumenta area cliccabile su touch devices */
        @media (hover: none) and (pointer: coarse) {
            button {
                padding: 12px 18px;
                font-size: 13px;
                min-height: 44px;
                min-width: 44px;
            }

            #controls {
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            }
        }
        
        #stats {
            margin-top: 10px;
            font-size: 10px;
            line-height: 1.4;
        }

        /* RESPONSIVE DESIGN - MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            #controls {
                top: 10px;
                right: 10px;
                left: auto;
                padding: 12px;
                font-size: 11px;
                max-width: 280px;
            }

            button {
                padding: 10px 12px;
                margin: 4px 2px;
                font-size: 12px;
            }

            #stats {
                margin-top: 8px;
                font-size: 9px;
                line-height: 1.3;
            }

            /* Scale frequency bars per mobile */
            #frequencyViz {
                bottom: 10px;
                height: 60px;
            }

            .freq-bar {
                width: 6px;
                max-height: 60px;
            }

            /* Speaker flashes - scale per schermi piccoli */
            .speaker-flash {
                width: 100px;
                height: 250px;
                filter: blur(20px);
            }

            .speaker-flash.left {
                left: 10%;
            }

            .speaker-flash.right {
                right: 10%;
            }

            /* Antenna beams - scale per mobile */
            .antenna-beam {
                width: 1px;
            }

            /* Circle pulse - pi√π piccolo su mobile */
            #circlePulse {
                width: 50px;
                height: 50px;
                border: 3px solid rgba(255, 255, 255, 0.9);
            }

            /* Geometric strobes - scale per mobile */
            #strobeCircle1 {
                width: 150px !important;
                height: 150px !important;
            }

            #strobeCircle2 {
                width: 300px !important;
                height: 300px !important;
            }

            /* Distortion zones - adjust positions for mobile */
            .distortion-zone {
                width: 120px !important;
                height: 180px !important;
            }

            .warp-zone {
                width: 200px !important;
                height: 120px !important;
            }

            .chroma-zone {
                width: 100px !important;
                height: 100px !important;
            }
        }

        @media (max-width: 480px) {
            #controls {
                top: 8px;
                right: 8px;
                padding: 10px;
                font-size: 10px;
                max-width: 240px;
            }

            button {
                padding: 8px 10px;
                margin: 3px 2px;
                font-size: 10px;
                width: 100%;
            }

            #frequencyViz {
                bottom: 5px;
                height: 50px;
                gap: 2px;
            }

            .freq-bar {
                width: 5px;
            }

        }
    </style>
</head>
<body>
    <!-- BACKGROUND -->
    <div id="background"></div>
    
    <!-- ANALOG EFFECTS LAYERS -->
    <div id="grainOverlay"></div>
    <div id="vhsLines"></div>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    
    <!-- STROBE FLASH -->
    <div id="strobeFlash"></div>
    
    <!-- GEOMETRIC STROBES (ottimizzati, pochi elementi) -->
    <div class="geo-strobe left-wall" id="strobeLeftWall"></div>
    <div class="geo-strobe right-wall" id="strobeRightWall"></div>
    <div class="geo-strobe circle-ring" id="strobeCircle1" style="width: 300px; height: 300px;"></div>
    <div class="geo-strobe circle-ring" id="strobeCircle2" style="width: 600px; height: 600px;"></div>
    <div class="geo-strobe horizontal-bottom" id="strobeBottom"></div>
    <div class="geo-strobe horizontal-top" id="strobeTop"></div>
    <div class="geo-strobe radial-burst" id="strobeRadial"></div>
    
    <!-- VORTEX ROTATION -->
    <canvas id="vortexRotation"></canvas>
    
    <!-- TUNNEL EFFECT 3D -->
    <div id="tunnelEffect"></div>
    
    <!-- CIRCLE PULSE (centro) -->
    <div id="circlePulse"></div>
    
    <!-- SPEAKER FLASHES (laterali) -->
    <div class="speaker-flash left"></div>
    <div class="speaker-flash right"></div>
    
    <!-- CROWD STROBE (folla) -->
    <div id="crowdStrobe"></div>
    
    <!-- ANTENNA BEAMS (centro alto) -->
    <div class="antenna-beam left"></div>
    <div class="antenna-beam center"></div>
    <div class="antenna-beam right"></div>
    
    <!-- üåÄ DISTORTION ZONES - zone di distorsione parziale -->
    <div class="distortion-zone" id="distort1"></div>
    <div class="distortion-zone" id="distort2"></div>
    <div class="distortion-zone" id="distort3"></div>
    <div class="warp-zone" id="warp1"></div>
    <div class="warp-zone" id="warp2"></div>
    <div class="chroma-zone" id="chroma1"></div>
    <div class="chroma-zone" id="chroma2"></div>
    <div class="chroma-zone" id="chroma3"></div>
    
    <!-- üí´ SUPER SPATIAL GLOW STROBO -->
    <div id="spatialStrobo"></div>
    
    <!-- üåÄ LOCALIZED SPIRAL ZOOM VORTEXES -->
    <div class="spiral-vortex" id="spiral1"></div>
    <div class="spiral-vortex" id="spiral2"></div>
    <div class="spiral-vortex" id="spiral3"></div>
    <div class="spiral-vortex" id="spiral4"></div>
    <div class="spiral-vortex" id="spiral5"></div>
    
    <!-- ‚ö´‚ö™ NEGATIVE LAYER - effetto negativo con raggi rotativi -->
    <div id="negativeLayer">
        <div class="rotating-rays single-beam" id="rays1"></div>
        <div class="rotating-rays multi-beam" id="rays2"></div>
        <div class="rotating-rays spiral-beam" id="rays3"></div>
        <div class="rotating-rays cross-beam" id="rays4"></div>
    </div>
    
    <!-- ‚≠ï CIRCULAR STROBO - cerchi concentrici espandenti -->
    <div class="circular-strobo" id="circle1"></div>
    <div class="circular-strobo" id="circle2"></div>
    <div class="circular-strobo" id="circle3"></div>
    <div class="circular-strobo" id="circle4"></div>
    
    <!-- üåä FRACTAL TEARS - distorsioni frattali organiche -->
    <div class="fractal-tear" id="tear1"></div>
    <div class="fractal-tear" id="tear2"></div>
    <div class="fractal-tear" id="tear3"></div>
    <div class="fractal-tear" id="tear4"></div>
    <div class="fractal-tear" id="tear5"></div>
    <div class="fractal-tear" id="tear6"></div>

    <!-- ‚ú® SILVER GLOW PARTICLES - glow argentati stroboscopici -->
    <div class="silver-glow-particle" id="glow1"></div>
    <div class="silver-glow-particle" id="glow2"></div>
    <div class="silver-glow-particle" id="glow3"></div>
    <div class="silver-glow-particle" id="glow4"></div>
    <div class="silver-glow-particle" id="glow5"></div>
    <div class="silver-glow-particle" id="glow6"></div>
    <div class="silver-glow-particle" id="glow7"></div>
    <div class="silver-glow-particle" id="glow8"></div>

    <!-- üåÄ SPIRAL WHIRL - spiraloidi rotativi -->
    <div class="spiral-whirl" id="whirl1"></div>
    <div class="spiral-whirl" id="whirl2"></div>
    <div class="spiral-whirl" id="whirl3"></div>
    <div class="spiral-whirl" id="whirl4"></div>

    <!-- ‚ú® SHIMMER TWINKLE - scintillio argentato -->
    <div class="shimmer-twinkle" id="twinkle1"></div>
    <div class="shimmer-twinkle" id="twinkle2"></div>
    <div class="shimmer-twinkle" id="twinkle3"></div>
    <div class="shimmer-twinkle" id="twinkle4"></div>
    <div class="shimmer-twinkle" id="twinkle5"></div>

    <!-- FREQUENCY VISUALIZER -->
    <div id="frequencyViz"></div>

    <!-- üí´ DREAM SOUNDSYSTEM FLASH LAYER - blurred memories of parties -->
    <div id="dreamLayer">
        <div class="dream-image" id="dream1"></div>
        <div class="dream-image" id="dream2"></div>
        <div class="dream-image" id="dream3"></div>
        <div class="dream-image" id="dream4"></div>
    </div>

    <!-- MINIMAL PLAY BUTTON - appears if autoplay fails -->
    <div id="minimalPlay">‚ñ∂Ô∏è</div>

    <!-- MENU TOGGLE BUTTON -->
    <div id="menuToggle" class="show">‚ò∞</div>

    <!-- CONTROLS -->
    <div id="controls">
        <div style="font-weight: bold; margin-bottom: 10px;">FREE UNDERGROUND TEKNO</div>
        <button id="startBtn">‚ñ∂Ô∏è START</button>
        <button id="stopBtn">‚èπÔ∏è STOP</button>
        <button id="hideBtn">üëÅÔ∏è HIDE</button>
        <div id="stats">
            <div>Bass: <span id="bassVal">0</span>%</div>
            <div>Mid: <span id="midVal">0</span>%</div>
            <div>Treble: <span id="trebleVal">0</span>%</div>
            <div id="debugAudio" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #fff; font-size: 8px; display: none;">
                <div>Audio: <span id="audioStatus">OFF</span></div>
                <div>Signal: <span id="signalStatus">No data</span></div>
            </div>
        </div>
    </div>

    <script>
        const AUDIO_URL = 'https://radio.freeundergroundtekno.org/listen/free_underground_tekno/radio.mp3';
        
        let audioContext = null;
        let audioElement = null;
        let analyser = null;
        let isPlaying = false;
        let animationId = null;
        
        // DOM elements
        const controls = document.getElementById('controls');
        const background = document.getElementById('background');
        const strobeFlash = document.getElementById('strobeFlash');
        const circlePulse = document.getElementById('circlePulse');
        const speakerFlashes = document.querySelectorAll('.speaker-flash');
        const crowdStrobe = document.getElementById('crowdStrobe');
        const antennaBeams = document.querySelectorAll('.antenna-beam');
        const vortexCanvas = document.getElementById('vortexRotation');
        const vortexCtx = vortexCanvas.getContext('2d');
        const tunnelEffect = document.getElementById('tunnelEffect');
        const frequencyViz = document.getElementById('frequencyViz');
        const vhsLines = document.getElementById('vhsLines');
        const grainOverlay = document.getElementById('grainOverlay');
        
        // Geometric strobes
        const strobeLeftWall = document.getElementById('strobeLeftWall');
        const strobeRightWall = document.getElementById('strobeRightWall');
        const strobeCircle1 = document.getElementById('strobeCircle1');
        const strobeCircle2 = document.getElementById('strobeCircle2');
        const strobeBottom = document.getElementById('strobeBottom');
        const strobeTop = document.getElementById('strobeTop');
        const strobeRadial = document.getElementById('strobeRadial');
        const geoStrobes = [strobeLeftWall, strobeRightWall, strobeCircle1, strobeCircle2, strobeBottom, strobeTop, strobeRadial];
        
        // üí´ Spatial strobo
        const spatialStrobo = document.getElementById('spatialStrobo');
        const stroboPatterns = ['radial-explosion', 'cross-beam', 'diamond-burst', 'spiral-glow', 'ring-pulse'];
        const stroboColors = [
            'rgba(255, 0, 255, 0.9)',   // magenta
            'rgba(0, 255, 255, 0.9)',   // cyan
            'rgba(255, 255, 0, 0.9)',   // yellow
            'rgba(0, 255, 0, 0.9)',     // green
            'rgba(255, 0, 0, 0.9)',     // red
            'rgba(0, 100, 255, 0.9)',   // blue
            'rgba(255, 255, 255, 0.9)'  // white
        ];
        let currentStroboPattern = stroboPatterns[0];
        let currentStroboColor = stroboColors[0];
        
        // üåÄ Spiral vortexes
        const spiralVortexes = [
            document.getElementById('spiral1'),
            document.getElementById('spiral2'),
            document.getElementById('spiral3'),
            document.getElementById('spiral4'),
            document.getElementById('spiral5')
        ];
        
        // Posizioni strategiche per le spirali (speaker stacks, centro, crowd, antenna)
        const spiralPositions = [
            { top: '25%', left: '15%' },   // stack speaker sinistro
            { top: '25%', left: '85%' },   // stack speaker destro
            { top: '50%', left: '50%' },   // centro spirale principale
            { top: '15%', left: '50%' },   // zona antenna
            { bottom: '25%', left: '50%' } // zona crowd
        ];
        
        // Colori e dimensioni per le spirali
        const spiralColors = [
            'rgba(255, 0, 255, 0.7)',   // magenta
            'rgba(0, 255, 255, 0.7)',   // cyan
            'rgba(255, 255, 0, 0.7)',   // yellow
            'rgba(0, 255, 0, 0.7)',     // green
            'rgba(255, 100, 0, 0.7)'    // orange
        ];
        
        const spiralAnimations = ['active', 'implode', 'pulse'];
        
        // Rileva se √® mobile
        const isMobile = window.innerWidth <= 768;
        const isSmallMobile = window.innerWidth <= 480;

        // Funzione per scalare le posizioni in base al viewport
        function adaptToViewport() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            if (width <= 768) {
                // Scala le posizioni delle spirali per mobile
                const mobilePositions = [
                    { top: '20%', left: '15%' },   // stack speaker sinistro
                    { top: '20%', left: '85%' },   // stack speaker destro
                    { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },   // centro
                    { top: '15%', left: '50%', transform: 'translate(-50%, -50%)' },   // antenna
                    { bottom: '20%', left: '50%', transform: 'translate(-50%, 0%)' }   // crowd
                ];

                spiralVortexes.forEach((vortex, i) => {
                    Object.assign(vortex.style, mobilePositions[i]);
                    // Riduci dimensioni su mobile
                    if (width <= 480) {
                        vortex.style.width = '60px';
                        vortex.style.height = '60px';
                    } else {
                        vortex.style.width = '80px';
                        vortex.style.height = '80px';
                    }
                });

                // Scala distortion zones per mobile
                const mobileDistortPositions = [
                    { top: '20%', left: '15%', width: '100px', height: '150px' },
                    { top: '20%', right: '15%', width: '100px', height: '150px' },
                    { top: '45%', left: '50%', width: '120px', height: '120px', transform: 'translateX(-50%)' }
                ];

                distortZones.forEach((zone, i) => {
                    Object.assign(zone.style, mobileDistortPositions[i]);
                });

                // Scala warp zones per mobile
                const mobileWarpPositions = [
                    { top: '10%', left: '25%', width: '150px', height: '100px' },
                    { bottom: '15%', left: '50%', width: '200px', height: '120px', transform: 'translateX(-50%)' }
                ];

                warpZones.forEach((zone, i) => {
                    Object.assign(zone.style, mobileWarpPositions[i]);
                });

                // Scala chroma zones per mobile
                const mobileChromaPositions = [
                    { top: '40%', left: '10%', width: '80px', height: '80px' },
                    { top: '40%', right: '10%', width: '80px', height: '80px' },
                    { top: '60%', left: '50%', width: '100px', height: '100px', transform: 'translateX(-50%)' }
                ];

                chromaZones.forEach((zone, i) => {
                    Object.assign(zone.style, mobileChromaPositions[i]);
                });
            } else {
                // Desktop layout
                spiralVortexes.forEach((vortex, i) => {
                    Object.assign(vortex.style, spiralPositions[i]);
                });
                distortZones.forEach((zone, i) => {
                    Object.assign(zone.style, distortPositions[i]);
                });
                warpZones.forEach((zone, i) => {
                    Object.assign(zone.style, warpPositions[i]);
                });
                chromaZones.forEach((zone, i) => {
                    Object.assign(zone.style, chromaPositions[i]);
                });
            }
        }

        // ‚ö´‚ö™ Negative layer con raggi rotativi
        const negativeLayer = document.getElementById('negativeLayer');
        const rotatingRays = [
            document.getElementById('rays1'),
            document.getElementById('rays2'),
            document.getElementById('rays3'),
            document.getElementById('rays4')
        ];
        
        // ‚≠ï Circular strobo
        const circularStrobos = [
            document.getElementById('circle1'),
            document.getElementById('circle2'),
            document.getElementById('circle3'),
            document.getElementById('circle4')
        ];
        
        // üåä Fractal tears - distorsioni frattali
        const fractalTears = [
            document.getElementById('tear1'),
            document.getElementById('tear2'),
            document.getElementById('tear3'),
            document.getElementById('tear4'),
            document.getElementById('tear5'),
            document.getElementById('tear6')
        ];
        
        // Forme frattali organiche (SVG clip-path)
        const fractalShapes = [
            'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)',
            'ellipse(40% 35% at 50% 50%)',
            'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
            'polygon(20% 0%, 80% 0%, 100% 20%, 100% 80%, 80% 100%, 20% 100%, 0% 80%, 0% 20%)',
            'circle(45% at 50% 50%)',
            'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'
        ];
        
        // Stats displays
        const bassVal = document.getElementById('bassVal');
        const midVal = document.getElementById('midVal');
        const trebleVal = document.getElementById('trebleVal');
        const debugAudio = document.getElementById('debugAudio');
        const audioStatus = document.getElementById('audioStatus');
        const signalStatus = document.getElementById('signalStatus');

        // Show debug on mobile
        if (isMobile) {
            debugAudio.style.display = 'block';
        }
        
        // üåÄ Distortion zones
        const distortZones = [
            document.getElementById('distort1'),
            document.getElementById('distort2'),
            document.getElementById('distort3')
        ];
        const warpZones = [
            document.getElementById('warp1'),
            document.getElementById('warp2')
        ];
        const chromaZones = [
            document.getElementById('chroma1'),
            document.getElementById('chroma2'),
            document.getElementById('chroma3')
        ];
        
        // Posiziona zone di distorsione in punti strategici (speaker stacks, centro, crowd)
        const distortPositions = [
            { top: '20%', left: '15%', width: '200px', height: '300px' },  // stack sinistro
            { top: '20%', right: '15%', width: '200px', height: '300px' }, // stack destro
            { top: '35%', left: '50%', width: '250px', height: '250px', transform: 'translateX(-50%)' }, // centro spirale
        ];
        
        const warpPositions = [
            { top: '10%', left: '30%', width: '300px', height: '150px' }, // antenna zone
            { bottom: '15%', left: '50%', width: '400px', height: '200px', transform: 'translateX(-50%)' }, // crowd zone
        ];
        
        const chromaPositions = [
            { top: '40%', left: '10%', width: '150px', height: '150px' },  // lato sinistro
            { top: '40%', right: '10%', width: '150px', height: '150px' }, // lato destro
            { top: '60%', left: '50%', width: '180px', height: '180px', transform: 'translateX(-50%)' }, // basso centro
        ];
        
        distortZones.forEach((zone, i) => {
            Object.assign(zone.style, distortPositions[i]);
        });
        
        warpZones.forEach((zone, i) => {
            Object.assign(zone.style, warpPositions[i]);
        });
        
        chromaZones.forEach((zone, i) => {
            Object.assign(zone.style, chromaPositions[i]);
        });

        // Inizializza le posizioni responsive e ridimensionamento
        adaptToViewport();

        // Re-adatta quando la finestra viene ridimensionata
        window.addEventListener('resize', adaptToViewport);

        // Setup canvas
        vortexCanvas.width = window.innerWidth;
        vortexCanvas.height = window.innerHeight;
        
        // Create tunnel rings (OTTIMIZZATO: ancora meno su mobile)
        const tunnelRingCount = isSmallMobile ? 3 : isMobile ? 4 : 6;
        for (let i = 0; i < tunnelRingCount; i++) {
            const ring = document.createElement('div');
            ring.className = 'tunnel-ring';
            ring.style.animationDelay = `${i * 0.5}s`;
            tunnelEffect.appendChild(ring);
        }
        
        // Create VHS scan lines
        for (let i = 0; i < 5; i++) {
            const line = document.createElement('div');
            line.className = 'vhs-line';
            line.style.animationDelay = `${i * 1.6}s`;
            vhsLines.appendChild(line);
        }
        
        // Create dust particles (OTTIMIZZATO: ancora meno su mobile)
        const dustParticleCount = isSmallMobile ? 5 : isMobile ? 8 : 15;
        for (let i = 0; i < dustParticleCount; i++) {
            const dust = document.createElement('div');
            dust.className = 'dust-particle';
            dust.style.left = Math.random() * 100 + '%';
            dust.style.top = Math.random() * 100 + '%';
            dust.style.setProperty('--dust-x', (Math.random() - 0.5) * 200 + 'px');
            dust.style.setProperty('--dust-y', (Math.random() - 0.5) * 200 + 'px');
            dust.style.animationDelay = Math.random() * 20 + 's';
            dust.style.animationDuration = (15 + Math.random() * 10) + 's';
            document.body.appendChild(dust);
        }
        
        // Create frequency bars (OTTIMIZZATO: meno barre)
        const barCount = 32; // ridotto da 40 per performance
        for (let i = 0; i < barCount; i++) {
            const bar = document.createElement('div');
            bar.className = 'freq-bar';
            bar.style.height = '10px';
            frequencyViz.appendChild(bar);
        }
        const freqBars = document.querySelectorAll('.freq-bar');
        
        // Detect device type
        const isDesktop = window.innerWidth > 768;

        // Performance optimization: detect slow devices
        const isSlowDevice = navigator.hardwareConcurrency <= 4 || !navigator.deviceMemory || navigator.deviceMemory <= 4;
        console.log(`Device: ${isDesktop ? 'DESKTOP' : 'MOBILE'} | Slow Device: ${isSlowDevice}`);

        // Frame rate throttling for slow devices (30fps vs 60fps)
        let lastFrameTime = 0;
        const targetFrameTime = isSlowDevice ? 1000 / 30 : 1000 / 60; // 30fps or 60fps
        let skippedFrames = 0;

        // Get UI elements
        const minimalPlay = document.getElementById('minimalPlay');
        const menuToggle = document.getElementById('menuToggle');

        // Button listeners
        document.getElementById('startBtn').addEventListener('click', startAudio);
        document.getElementById('stopBtn').addEventListener('click', stopAudio);
        document.getElementById('hideBtn').addEventListener('click', () => {
            controls.classList.toggle('hidden');
            // Show minimal play button when hiding controls
            if (controls.classList.contains('hidden')) {
                minimalPlay.classList.add('show');
                if (isDesktop) {
                    menuToggle.textContent = '‚ò∞';
                }
            } else {
                minimalPlay.classList.remove('show');
            }
        });

        // Minimal play button for autoplay fallback
        minimalPlay.addEventListener('click', async () => {
            if (isPlaying) return;
            // Try to resume AudioContext if suspended
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
                console.log('‚èØÔ∏è AudioContext resumed by user click');
            }
            if (!isPlaying) {
                await startAudio();
            }
            // Show full controls
            controls.classList.remove('hidden');
            minimalPlay.classList.remove('show');
            if (isDesktop) {
                menuToggle.textContent = '‚úï';
            }
        });

        // Menu toggle button (desktop only)
        menuToggle.addEventListener('click', () => {
            controls.classList.toggle('hidden');
            if (controls.classList.contains('hidden')) {
                menuToggle.textContent = '‚ò∞'; // menu closed
                minimalPlay.classList.add('show'); // show play button
            } else {
                menuToggle.textContent = '‚úï'; // menu open
                minimalPlay.classList.remove('show'); // hide play button
            }
        });

        // Click/key to show controls
        document.addEventListener('click', (e) => {
            if (!controls.contains(e.target) && !menuToggle.contains(e.target) && controls.classList.contains('hidden')) {
                controls.classList.remove('hidden');
                if (isDesktop) {
                    menuToggle.textContent = '‚úï';
                }
            }
        });

        document.addEventListener('keydown', () => {
            controls.classList.toggle('hidden');
            if (isDesktop && !controls.classList.contains('hidden')) {
                menuToggle.textContent = '‚úï';
            } else if (isDesktop && controls.classList.contains('hidden')) {
                menuToggle.textContent = '‚ò∞';
            }
        });

        // Try autoplay on load, show minimal play button if it fails
        window.addEventListener('load', async () => {
            console.log('‚èØÔ∏è Attempting to start audio automatically...');
            try {
                await startAudio();
                console.log('‚úÖ Autoplay successful!');
                minimalPlay.classList.remove('show');
                // Hide menu on desktop after successful autoplay
                if (isDesktop) {
                    controls.classList.add('hidden');
                    menuToggle.textContent = '‚ò∞';
                }
            } catch (err) {
                console.log('‚ö†Ô∏è Autoplay failed, showing minimal play button');
                // Show minimal play button if autoplay fails
                minimalPlay.classList.add('show');
                // Show controls on mobile
                if (!isDesktop) {
                    controls.classList.remove('hidden');
                }
            }
        });

        // Beat detection
        let beatHistory = [];
        let lastBeatTime = 0;
        let bpm = 0;
        
        // Motion effects
        let lastZoomBurst = 0;
        let lastShakeBurst = 0;
        let motionBlurActive = false;
        
        // Psychedelic state machine
        let psychState = 'normal'; // normal, trip, khole, strobe, aberration, vhs
        let stateTimer = 0;
        let nextStateChange = Math.random() * 20000 + 30000; // 30-50s

        // ‚ú® MAGIC GLOW ELEMENTS - inizializza i nuovi effetti
        const silverGlowParticles = [
            ...document.querySelectorAll('.silver-glow-particle')
        ];
        const spiralWhirls = [
            ...document.querySelectorAll('.spiral-whirl')
        ];
        const shimmerTwinkles = [
            ...document.querySelectorAll('.shimmer-twinkle')
        ];

        // Posizioni strategic per lo scattering degli effetti
        const magicPositions = [
            { top: '15%', left: '20%' },   // alto sinistro
            { top: '20%', right: '25%' },  // alto destro
            { top: '45%', left: '10%' },   // sinistra medio
            { top: '50%', right: '15%' },  // destra medio
            { top: '75%', left: '30%' },   // basso sinistro
            { top: '80%', right: '20%' },  // basso destro
            { top: '35%', left: '50%', transform: 'translateX(-50%)' }, // centro
            { top: '65%', left: '50%', transform: 'translateX(-50%)' }   // centro basso
        ];

        // üí´ DREAM SOUNDSYSTEM SYSTEM - blurred memory flashes
        const dreamImages = [
            ...document.querySelectorAll('.dream-image')
        ];
        const dreamImagePaths = [
            './images/1.webp', './images/2.webp', './images/3.webp',
            './images/4.webp', './images/5.webp', './images/6.webp',
            './images/7.webp', './images/8.webp', './images/9.webp',
            './images/10.webp', './images/11.webp', './images/12.webp',
            './images/13.webp', './images/14.webp', './images/15.webp',
            './images/16.webp', './images/17.webp', './images/18.webp'
        ];

        let dreamStates = dreamImages.map(() => ({ active: false, lastTrigger: 0 }));
        let lastDreamFlash = 0;
        let dreamIntensity = 0; // 0-1, derived from bass+mid combo

        // Preload dream images
        dreamImages.forEach(img => {
            img.style.backgroundImage = '';  // Will be set on demand
        });

        function triggerDreamFlash(intensity = 'normal') {
            // Only trigger occasionally (every 2-5 seconds)
            if (Date.now() - lastDreamFlash < 2000) return;

            const dreamIndex = Math.floor(Math.random() * dreamImages.length);
            const dream = dreamImages[dreamIndex];
            const imageIndex = Math.floor(Math.random() * dreamImagePaths.length);

            // Set random image from collection
            dream.style.backgroundImage = `url('${dreamImagePaths[imageIndex]}')`;

            // Remove all previous states
            dream.classList.remove('dreaming', 'deep-dream', 'lucid-dream', 'pulse-dream', 'glow-dream');

            // Choose dream state based on frequency context
            const states = ['dreaming', 'lucid-dream', 'pulse-dream'];
            const dreamState = states[Math.floor(Math.random() * states.length)];

            dream.classList.add(dreamState);
            dreamStates[dreamIndex].active = true;
            dreamStates[dreamIndex].lastTrigger = Date.now();

            // Clear after animation completes
            setTimeout(() => {
                dream.classList.remove('dreaming', 'deep-dream', 'lucid-dream', 'pulse-dream', 'glow-dream');
                dream.style.backgroundImage = '';
                dreamStates[dreamIndex].active = false;
            }, 3500);

            lastDreamFlash = Date.now();
            console.log(`üí´ Dream flash #${imageIndex} - ${dreamState}`);
        }

        // Spirali 3D SVG - renderizza come path
        function createSpiralSvg(color) {
            const size = 50;
            return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="filter: drop-shadow(0 0 15px ${color});">
                <path d="M ${size/2} ${size/2} Q ${size*0.8} ${size*0.2} ${size} ${size/2} T ${size*0.2} ${size}" stroke="${color}" stroke-width="2" fill="none" opacity="0.9"/>
            </svg>`;
        }

        function changeState() {
            const states = ['normal', 'trip', 'khole', 'strobe', 'aberration', 'vhs'];
            const weights = [30, 20, 15, 10, 15, 10]; // probability weights
            
            // Remove current state classes
            document.body.classList.remove('trip-mode', 'khole-mode', 'aberration-mode');
            vhsLines.style.opacity = '0';
            grainOverlay.style.opacity = '0.15';
            
            // Weighted random selection
            const total = weights.reduce((a, b) => a + b);
            let rand = Math.random() * total;
            let newState = 'normal';
            
            for (let i = 0; i < states.length; i++) {
                rand -= weights[i];
                if (rand <= 0) {
                    newState = states[i];
                    break;
                }
            }
            
            psychState = newState;
            console.log(`üé® State change: ${newState}`);
            
            // Apply state
            if (newState === 'trip') {
                document.body.classList.add('trip-mode');
                nextStateChange = 15000 + Math.random() * 15000; // 15-30s
            } else if (newState === 'khole') {
                document.body.classList.add('khole-mode');
                nextStateChange = 10000 + Math.random() * 10000; // 10-20s
            } else if (newState === 'strobe') {
                startStrobeSequence();
                nextStateChange = 5000; // 5s
            } else if (newState === 'aberration') {
                document.body.classList.add('aberration-mode');
                nextStateChange = 8000 + Math.random() * 7000; // 8-15s
            } else if (newState === 'vhs') {
                vhsLines.style.opacity = '0.6';
                grainOverlay.style.opacity = '0.4';
                nextStateChange = 10000 + Math.random() * 10000; // 10-20s
            } else {
                nextStateChange = 30000 + Math.random() * 30000; // 30-60s
            }
            
            stateTimer = 0;
        }
        
        // Strobe sequence
        function startStrobeSequence() {
            let count = 0;
            const maxFlashes = 10 + Math.floor(Math.random() * 20);
            const strobeInterval = setInterval(() => {
                strobeFlash.style.opacity = '1';
                setTimeout(() => {
                    strobeFlash.style.opacity = '0';
                }, 50 + Math.random() * 50);
                
                count++;
                if (count >= maxFlashes) {
                    clearInterval(strobeInterval);
                    psychState = 'normal';
                }
            }, 100 + Math.random() * 100);
        }
        
        async function startAudio() {
            if (isPlaying) return;

            try {
                console.log('üöÄ Starting audio stream...');

                // Create AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('üîä AudioContext created:', audioContext.state);

                // Create audio element with proper stream configuration
                audioElement = new Audio();
                audioElement.src = AUDIO_URL;
                audioElement.crossOrigin = 'anonymous';
                audioElement.preload = 'metadata';
                audioElement.loop = false; // CRITICAL: Prevent looping on stream end
                audioElement.autoplay = false;

                // Setup analyser for frequency analysis
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;

                // Create source and connect to analyser
                const source = audioContext.createMediaElementSource(audioElement);
                source.connect(analyser);
                analyser.connect(audioContext.destination);

                // Resume audio context if suspended (Safari requirement)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    console.log('‚è∏Ô∏è AudioContext resumed');
                }

                // Setup buffer monitoring for stream stability
                let bufferingStartTime = null;
                let connectionStable = false;

                // Listen for stream buffering issues
                audioElement.addEventListener('loadstart', () => {
                    console.log('üì° Audio stream loading...');
                    bufferingStartTime = Date.now();
                    connectionStable = false;
                });

                audioElement.addEventListener('canplay', () => {
                    connectionStable = true;
                    const bufferTime = Date.now() - bufferingStartTime;
                    console.log(`‚úÖ Audio stream ready (buffered in ${bufferTime}ms)`);
                });

                audioElement.addEventListener('playing', () => {
                    console.log('‚ñ∂Ô∏è Stream playing');
                });

                // Prevent glitch: handle network interruptions
                audioElement.addEventListener('stalled', () => {
                    console.warn('‚ö†Ô∏è Stream stalled - buffering...');
                });

                audioElement.addEventListener('pause', () => {
                    if (isPlaying) {
                        console.warn('‚ö†Ô∏è Stream paused unexpectedly');
                    }
                });

                // Error handling for network issues
                audioElement.addEventListener('error', (e) => {
                    console.error('‚ùå Audio stream error:', e.target.error);
                    if (e.target.error.code === e.target.error.MEDIA_ERR_NETWORK) {
                        console.error('Network error - stream unreachable');
                    } else if (e.target.error.code === e.target.error.MEDIA_ERR_DECODE) {
                        console.error('Decode error - invalid stream format');
                    }
                });

                // Handle stream end (should not happen for infinite stream)
                audioElement.addEventListener('ended', () => {
                    console.log('Stream ended unexpectedly');
                    isPlaying = false;
                    audioStatus.textContent = 'STREAM ENDED';
                });

                // Start playback
                await audioElement.play();
                isPlaying = true;
                audioStatus.textContent = 'STREAMING';

                console.log('‚úÖ Audio stream started!');
                animate();

            } catch (err) {
                console.error('‚ùå Audio error:', err);
                isPlaying = false;
                audioStatus.textContent = 'ERROR';
            }
        }
        
        function stopAudio() {
            if (!isPlaying) return;

            try {
                // Stop audio playback
                if (audioElement) {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                    audioElement.src = ''; // Clear stream source
                }

                // Stop animation loop
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }

                // Reset UI
                isPlaying = false;
                audioStatus.textContent = 'STOPPED';
                signalStatus.textContent = 'Ready';
                console.log('‚èπÔ∏è Audio stream stopped');
            } catch (err) {
                console.error('Error stopping audio:', err);
            }
        }
        
        let vortexRotation = 0;
        let zoomIntensity = 1;

        // Inizializza target point per il movimento della camera
        window.targetPoint = { x: 0, y: 0 };
        window.lastTargetChange = Date.now();
        window.currentEasing = 'easeInOut';

        function animate() {
            if (!isPlaying) return;

            // Frame rate throttling for performance
            const now = performance.now();
            if (now - lastFrameTime < targetFrameTime) {
                skippedFrames++;
                animationId = requestAnimationFrame(animate);
                return;
            }
            lastFrameTime = now;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // Frequency bands
            const bassData = dataArray.slice(0, 15);      // 0-250Hz
            const midData = dataArray.slice(40, 120);     // 500-2kHz
            const trebleData = dataArray.slice(150, 300); // 4-8kHz
            
            const bassLevel = bassData.reduce((a, b) => a + b) / (bassData.length * 255);
            const midLevel = midData.reduce((a, b) => a + b) / (midData.length * 255);
            const trebleLevel = trebleData.reduce((a, b) => a + b) / (trebleData.length * 255);
            
            // Overall energy
            const energy = (bassLevel + midLevel + trebleLevel) / 3;

            // üí´ DREAM SOUNDSYSTEM FLASH TRIGGERS - memoria fugace del suono
            // Dream conditions: specific frequency combinations during energetic moments
            dreamIntensity = (bassLevel * 0.4) + (midLevel * 0.6); // More mid-sensitive

            // Trigger 1: Strong mid-level with bass presence (party vibe)
            const dreamTrigger1 = bassLevel > (isMobile ? 0.4 : 0.6) &&
                                  midLevel > (isMobile ? 0.5 : 0.7) &&
                                  Math.random() > 0.92;  // Rare trigger (8% chance per frame)

            // Trigger 2: Peak energy moment with treble spike (climax effect)
            const dreamTrigger2 = energy > 0.7 &&
                                  trebleLevel > (isMobile ? 0.4 : 0.6) &&
                                  bassLevel > (isMobile ? 0.3 : 0.5) &&
                                  Math.random() > 0.88;  // Slightly less rare (12% chance)

            // Trigger 3: Sustained high mid-level (continuous presence)
            const dreamTrigger3 = midLevel > (isMobile ? 0.6 : 0.8) &&
                                  Date.now() - lastDreamFlash > 3000 &&  // Max once every 3s
                                  Math.random() > 0.94;  // Very rare (6% chance)

            if (dreamTrigger1) {
                triggerDreamFlash('party');
            } else if (dreamTrigger2) {
                triggerDreamFlash('peak');
            } else if (dreamTrigger3) {
                triggerDreamFlash('sustained');
            }

            // State machine timer
            stateTimer += 16; // ~60fps
            if (stateTimer > nextStateChange) {
                changeState();
            }

            // üéØ CALCOLO ZOOM E ROTAZIONE - AUMENTATO PER EFFETTO SOTTOCASSA!
            zoomIntensity = 1 + bassLevel * 0.6; // da 0.3 a 0.6 = ZOOM DOPPIO!
            const rotateAmount = energy * 5;
            
            // üé≠ TARGET POINT - punto casuale verso cui "guardare" (cambia ogni 3-8 secondi)
            if (!window.targetPoint || Date.now() - window.lastTargetChange > (3000 + Math.random() * 5000)) {
                window.targetPoint = {
                    x: (Math.random() - 0.5) * 100, // -50 a +50px
                    y: (Math.random() - 0.5) * 80   // -40 a +40px
                };
                window.lastTargetChange = Date.now();
                
                // Scegli easing casuale per il prossimo ciclo
                const easingTypes = ['easeInOut', 'easeOut', 'easeIn', 'bounce'];
                window.currentEasing = easingTypes[Math.floor(Math.random() * easingTypes.length)];
            }
            
            // üé® FUNZIONI DI EASING per movimento fluido e ritmato
            const easing = {
                easeInOut: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
                easeOut: (t) => t * (2 - t), // decelerazione
                easeIn: (t) => t * t, // accelerazione
                bounce: (t) => {
                    if (t < 0.5) return 8 * t * t * t * t;
                    return 1 - 8 * (--t) * t * t * t;
                }
            };
            
            // Applica easing corrente
            const currentEasingFunc = easing[window.currentEasing || 'easeInOut'];
            
            // Beat detection - SOGLIA RIDOTTA per mobile
            const beatThreshold = isMobile ? 0.3 : 0.7;
            if (bassLevel > beatThreshold && Date.now() - lastBeatTime > 200) {
                beatHistory.push(Date.now());
                if (beatHistory.length > 10) beatHistory.shift();

                if (beatHistory.length >= 2) {
                    const intervals = [];
                    for (let i = 1; i < beatHistory.length; i++) {
                        intervals.push(beatHistory[i] - beatHistory[i-1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                    bpm = Math.round(60000 / avgInterval);
                }

                lastBeatTime = Date.now();

                // Crowd strobe on beat - AUMENTATO
                crowdStrobe.style.opacity = isMobile ? '0.95' : '1';
                setTimeout(() => {
                    crowdStrobe.style.opacity = '0';
                }, 120);

                // üí´ SUPER SPATIAL GLOW STROBO - attiva su cassa dritta (SOGLIA RIDOTTA)
                const spatialStroboThreshold = isMobile ? 0.35 : 0.8;
                if (bassLevel > spatialStroboThreshold && Math.random() > 0.2) { // AUMENTATA la frequenza (0.5 -> 0.2)
                    // Cambia pattern e colore casualmente
                    if (Math.random() > 0.5) { // AUMENTATA la frequenza (0.7 -> 0.5)
                        currentStroboPattern = stroboPatterns[Math.floor(Math.random() * stroboPatterns.length)];
                        currentStroboColor = stroboColors[Math.floor(Math.random() * stroboColors.length)];
                        spatialStrobo.className = currentStroboPattern;
                        spatialStrobo.style.setProperty('--glow-color', currentStroboColor);
                    }

                    // Flash strobo spaziale - AUMENTATO OPACIT√Ä
                    spatialStrobo.style.opacity = isMobile ? '1' : '0.9';
                    setTimeout(() => {
                        spatialStrobo.style.opacity = '0';
                    }, 50 + Math.random() * 80); // durata aumentata 50-130ms
                }

                // üåÄ SPIRAL ZOOM VORTEXES - attiva spirali localizzate randomicamente
                const spiralBassThreshold = isMobile ? 0.35 : 0.8;
                // Su bassi forti: spirale explosion (zoom out)
                if (bassLevel > spiralBassThreshold && Math.random() > 0.2) { // AUMENTATA frequenza (0.65 -> 0.2)
                    const vortex = spiralVortexes[Math.floor(Math.random() * spiralVortexes.length)];
                    const color = spiralColors[Math.floor(Math.random() * spiralColors.length)];
                    const size = 100 + Math.random() * 150; // 100-250px
                    
                    vortex.style.width = size + 'px';
                    vortex.style.height = size + 'px';
                    vortex.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
                    vortex.classList.remove('implode', 'pulse');
                    vortex.classList.add('active');
                    
                    setTimeout(() => {
                        vortex.classList.remove('active');
                    }, 800);
                }
                
                // Su medi: spirale implode (zoom in) - SOGLIA RIDOTTA
                const midThreshold = isMobile ? 0.35 : 0.75;
                if (midLevel > midThreshold && Math.random() > 0.3) { // AUMENTATA frequenza (0.7 -> 0.3)
                    const vortex = spiralVortexes[Math.floor(Math.random() * spiralVortexes.length)];
                    const color = spiralColors[Math.floor(Math.random() * spiralColors.length)];
                    const size = 120 + Math.random() * 100; // 120-220px

                    vortex.style.width = size + 'px';
                    vortex.style.height = size + 'px';
                    vortex.style.background = `conic-gradient(from 0deg, ${color} 0deg, transparent 120deg, ${color} 240deg, transparent 360deg)`;
                    vortex.classList.remove('active', 'pulse');
                    vortex.classList.add('implode');

                    setTimeout(() => {
                        vortex.classList.remove('implode');
                    }, 600);
                }

                // Su alti: spirale pulse (pulsante) - SOGLIA RIDOTTA
                const trebleThreshold = isMobile ? 0.3 : 0.7;
                if (trebleLevel > trebleThreshold && Math.random() > 0.35) { // AUMENTATA frequenza (0.75 -> 0.35)
                    const vortex = spiralVortexes[Math.floor(Math.random() * spiralVortexes.length)];
                    const color = spiralColors[Math.floor(Math.random() * spiralColors.length)];
                    const size = 80 + Math.random() * 80; // 80-160px

                    vortex.style.width = size + 'px';
                    vortex.style.height = size + 'px';
                    vortex.style.background = `radial-gradient(circle, transparent 20%, ${color} 40%, transparent 60%)`;
                    vortex.classList.remove('active', 'implode');
                    vortex.classList.add('pulse');

                    setTimeout(() => {
                        vortex.classList.remove('pulse');
                    }, 500);
                }

                // üéØ ZOOM BURST SOTTOCASSA - zoom PI√ô FREQUENTE e PI√ô POTENTE!
                const zoomThreshold = isMobile ? 0.35 : 0.8;
                if (bassLevel > zoomThreshold && Date.now() - lastZoomBurst > (isMobile ? 400 : 600) && Math.random() > (isMobile ? 0.2 : 0.4)) {
                    document.body.classList.add('zoom-burst');
                    lastZoomBurst = Date.now();
                    setTimeout(() => {
                        document.body.classList.remove('zoom-burst');
                    }, 300);
                }

                // üí• SHAKE BURST - scossa rapida su peak
                const shakeThreshold = isMobile ? 0.4 : 0.9;
                if (bassLevel > shakeThreshold && Date.now() - lastShakeBurst > (isMobile ? 800 : 1500) && Math.random() > (isMobile ? 0.3 : 0.7)) {
                    document.body.classList.add('shake-burst');
                    lastShakeBurst = Date.now();
                    setTimeout(() => {
                        document.body.classList.remove('shake-burst');
                    }, 200);
                }

                // Random strobe on peak beats - SOGLIA RIDOTTA
                const strobeThreshold = isMobile ? 0.35 : 0.85;
                if (bassLevel > strobeThreshold && Math.random() > (isMobile ? 0.3 : 0.7)) {
                    strobeFlash.style.opacity = isMobile ? '1' : '0.8';
                    setTimeout(() => {
                        strobeFlash.style.opacity = '0';
                    }, 40);
                }

                // Random VHS glitch on strong beats - SOGLIA RIDOTTA
                const vhsThreshold = isMobile ? 0.35 : 0.8;
                if (bassLevel > vhsThreshold && Math.random() > (isMobile ? 0.5 : 0.85)) {
                    vhsLines.style.opacity = isMobile ? '1' : '0.8';
                    background.style.transform = `scale(${zoomIntensity}) rotate(${rotateAmount}deg) translateX(${Math.random() * 10 - 5}px)`;
                    setTimeout(() => {
                        vhsLines.style.opacity = (psychState === 'vhs' ? '0.6' : '0');
                    }, 80);
                }
                
                // Random grain spike - SOGLIA RIDOTTA
                const grainThreshold = isMobile ? 0.3 : 0.7;
                if (energy > grainThreshold && Math.random() > (isMobile ? 0.5 : 0.9)) {
                    grainOverlay.style.opacity = isMobile ? '0.8' : '0.5';
                    setTimeout(() => {
                        grainOverlay.style.opacity = (psychState === 'vhs' ? '0.4' : '0.15');
                    }, 100);
                }

                // ‚ö´‚ö™ NEGATIVE LAYER - raggi rotativi POTENZIATI!
                // Su bassi: attiva raggi singoli o multipli - SOGLIA RIDOTTA
                const negRayBasaThreshold = isMobile ? 0.3 : 0.7;
                if (bassLevel > negRayBasaThreshold && Math.random() > (isMobile ? 0.05 : 0.3)) {
                    const rayPattern = Math.random() < 0.5 ? rotatingRays[0] : rotatingRays[1];
                    negativeLayer.style.opacity = isMobile ? '1' : '0.95';
                    rayPattern.style.opacity = '1';
                    rayPattern.classList.add('active');

                    setTimeout(() => {
                        negativeLayer.style.opacity = '0';
                        rayPattern.style.opacity = '0';
                        rayPattern.classList.remove('active');
                    }, 180 + Math.random() * 120); // 180-300ms
                }

                // Su alti: attiva spirale o croce - SOGLIA RIDOTTA
                const negRayTrebleThreshold = isMobile ? 0.25 : 0.65;
                if (trebleLevel > negRayTrebleThreshold && Math.random() > (isMobile ? 0.1 : 0.4)) {
                    const rayPattern = Math.random() < 0.5 ? rotatingRays[2] : rotatingRays[3];
                    negativeLayer.style.opacity = isMobile ? '1' : '0.98';
                    rayPattern.style.opacity = '1';
                    rayPattern.classList.add('active');

                    setTimeout(() => {
                        negativeLayer.style.opacity = '0';
                        rayPattern.style.opacity = '0';
                        rayPattern.classList.remove('active');
                    }, 150 + Math.random() * 100); // 150-250ms
                }

                // üåä FRACTAL TEARS - distorsioni frattali organiche - SOGLIA RIDOTTA
                const fractalThreshold = isMobile ? 0.35 : 0.78;
                if (bassLevel > fractalThreshold && Math.random() > (isMobile ? 0.2 : 0.5)) {
                    const tear = fractalTears[Math.floor(Math.random() * fractalTears.length)];
                    const shape = fractalShapes[Math.floor(Math.random() * fractalShapes.length)];
                    const size = 80 + Math.random() * 180; // 80-260px

                    // Posizione random
                    tear.style.top = (20 + Math.random() * 60) + '%';
                    tear.style.left = (10 + Math.random() * 80) + '%';
                    tear.style.width = size + 'px';
                    tear.style.height = size + 'px';
                    tear.style.clipPath = shape;
                    tear.classList.add('active');

                    setTimeout(() => tear.classList.remove('active'), 500);
                }

                // ‚≠ï CIRCULAR STROBO - cerchi concentrici espandenti - SOGLIA RIDOTTA
                const circularBassThreshold = isMobile ? 0.35 : 0.8;
                // Su bassi: lancia cerchi concentrici
                if (bassLevel > circularBassThreshold && Math.random() > (isMobile ? 0.15 : 0.5)) {
                    const circle = circularStrobos[Math.floor(Math.random() * circularStrobos.length)];
                    circle.classList.add('active');

                    setTimeout(() => {
                        circle.classList.remove('active');
                    }, 400);
                }

                // Su alti: lancia multipli cerchi veloci - SOGLIA RIDOTTA
                const circularTrebleThreshold = isMobile ? 0.3 : 0.75;
                if (trebleLevel > circularTrebleThreshold && Math.random() > (isMobile ? 0.2 : 0.55)) {
                    // Lancia 2-3 cerchi in rapida successione
                    const count = 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < count; i++) {
                        setTimeout(() => {
                            const circle = circularStrobos[Math.floor(Math.random() * circularStrobos.length)];
                            circle.classList.add('active');
                            setTimeout(() => circle.classList.remove('active'), 400);
                        }, i * 100); // sfasati di 100ms
                    }
                }

                // ‚ú® SILVER GLOW PARTICLES - glow argentati a ritmo medi
                const glowMidThreshold = isMobile ? 0.25 : 0.6;
                if (midLevel > glowMidThreshold && Math.random() > (isMobile ? 0.15 : 0.45)) {
                    const glow = silverGlowParticles[Math.floor(Math.random() * silverGlowParticles.length)];
                    const pos = magicPositions[Math.floor(Math.random() * magicPositions.length)];
                    const size = 40 + Math.random() * 80;
                    glow.style.width = size + 'px';
                    glow.style.height = size + 'px';
                    Object.assign(glow.style, pos);
                    glow.classList.add('active');
                    setTimeout(() => glow.classList.remove('active'), 600);
                }

                // üåÄ SPIRAL WHIRL - spiraloidi rotativi random a ritmo
                const whirlMidThreshold = isMobile ? 0.28 : 0.65;
                if (midLevel > whirlMidThreshold && Math.random() > (isMobile ? 0.2 : 0.5)) {
                    const whirl = spiralWhirls[Math.floor(Math.random() * spiralWhirls.length)];
                    const pos = magicPositions[Math.floor(Math.random() * magicPositions.length)];
                    const colors = ['rgba(200, 220, 255, 0.9)', 'rgba(150, 200, 255, 0.9)', 'rgba(220, 200, 255, 0.9)', 'rgba(255, 255, 200, 0.9)'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const size = 50 + Math.random() * 80;
                    whirl.style.width = size + 'px';
                    whirl.style.height = size + 'px';
                    whirl.innerHTML = createSpiralSvg(color);
                    Object.assign(whirl.style, pos);
                    whirl.classList.add('active');
                    setTimeout(() => {
                        whirl.classList.remove('active');
                        whirl.innerHTML = '';
                    }, 800);
                }

                // ‚ú® SHIMMER TWINKLE - scintillio argentato random
                const twinkleMidThreshold = isMobile ? 0.2 : 0.5;
                if (midLevel > twinkleMidThreshold && Math.random() > (isMobile ? 0.3 : 0.7)) {
                    const count = 1 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < count; i++) {
                        setTimeout(() => {
                            const twinkle = shimmerTwinkles[Math.floor(Math.random() * shimmerTwinkles.length)];
                            const pos = magicPositions[Math.floor(Math.random() * magicPositions.length)];
                            Object.assign(twinkle.style, pos);
                            twinkle.classList.add('active');
                            setTimeout(() => twinkle.classList.remove('active'), 400);
                        }, i * 50);
                    }
                }
                
                // ÔøΩ DISTORTION ZONES - distorsioni parziali graduali a tempo
                // Distorsioni su bassi (stack speaker) - DISABILITATO su slow devices
                if (!isSlowDevice) {
                    const distortThreshold = isMobile ? 0.3 : 0.75;
                    if (bassLevel > distortThreshold && Math.random() > (isMobile ? 0.3 : 0.7)) {
                        const zone = distortZones[Math.floor(Math.random() * distortZones.length)];
                        zone.classList.add('active');
                        setTimeout(() => zone.classList.remove('active'), 400);
                    }

                    // Warp glitch su medi (crowd e antenna zone) - SOGLIA RIDOTTA
                    const warpThreshold = isMobile ? 0.3 : 0.7;
                    if (midLevel > warpThreshold && Math.random() > (isMobile ? 0.3 : 0.75)) {
                        const zone = warpZones[Math.floor(Math.random() * warpZones.length)];
                        zone.classList.add('active');
                        setTimeout(() => zone.classList.remove('active'), 300);
                    }

                    // Chromatic split su alti (zone laterali) - SOGLIA RIDOTTA
                    const chromaThreshold = isMobile ? 0.25 : 0.7;
                    if (trebleLevel > chromaThreshold && Math.random() > (isMobile ? 0.3 : 0.8)) {
                        const zone = chromaZones[Math.floor(Math.random() * chromaZones.length)];
                        zone.classList.add('active');
                        setTimeout(() => zone.classList.remove('active'), 200);
                    }
                }
                
                // ÔøΩüéÜ GEOMETRIC STROBES - brillamenti geometrici sui beat
                // Bass -> cerchi + radial burst
                const geoStrobeThreshold = isMobile ? 0.3 : 0.75;
                if (bassLevel > geoStrobeThreshold && Math.random() > (isMobile ? 0.2 : 0.6)) {
                    const choice = Math.random();
                    if (choice < 0.4) {
                        // Cerchi concentrici - OPACIT√Ä AUMENTATA
                        strobeCircle1.style.opacity = isMobile ? '1' : '0.9';
                        strobeCircle2.style.opacity = isMobile ? '0.9' : '0.7';
                        setTimeout(() => {
                            strobeCircle1.style.opacity = '0';
                            strobeCircle2.style.opacity = '0';
                        }, 60);
                    } else if (choice < 0.7) {
                        // Radial burst dal centro - OPACIT√Ä AUMENTATA
                        strobeRadial.style.opacity = isMobile ? '1' : '0.8';
                        setTimeout(() => {
                            strobeRadial.style.opacity = '0';
                        }, 80);
                    } else {
                        // Bottom crowd flash - OPACIT√Ä AUMENTATA
                        strobeBottom.style.opacity = isMobile ? '1' : '0.9';
                        setTimeout(() => {
                            strobeBottom.style.opacity = '0';
                        }, 70);
                    }
                }
            }
            
            // Mid -> speaker walls laterali - SOGLIA RIDOTTA
            const speakerMidThreshold = isMobile ? 0.3 : 0.7;
            if (midLevel > speakerMidThreshold && Math.random() > (isMobile ? 0.3 : 0.8)) {
                if (Math.random() < 0.5) {
                    strobeLeftWall.style.opacity = isMobile ? '1' : '0.8';
                    setTimeout(() => {
                        strobeLeftWall.style.opacity = '0';
                    }, 50);
                } else {
                    strobeRightWall.style.opacity = isMobile ? '1' : '0.8';
                    setTimeout(() => {
                        strobeRightWall.style.opacity = '0';
                    }, 50);
                }
            }

            // Treble -> top flash (antenna beams) - SOGLIA RIDOTTA
            const antennaTrebleThreshold = isMobile ? 0.3 : 0.75;
            if (trebleLevel > antennaTrebleThreshold && Math.random() > (isMobile ? 0.3 : 0.85)) {
                strobeTop.style.opacity = isMobile ? '1' : '0.9';
                setTimeout(() => {
                    strobeTop.style.opacity = '0';
                }, 40);
            }

            // Peak energy -> random geometric strobe - SOGLIA RIDOTTA
            const peakEnergyThreshold = isMobile ? 0.3 : 0.8;
            if (energy > peakEnergyThreshold && Math.random() > (isMobile ? 0.7 : 0.92)) {
                const randomStrobe = geoStrobes[Math.floor(Math.random() * geoStrobes.length)];
                randomStrobe.style.opacity = isMobile ? '1' : '0.95';
                setTimeout(() => {
                    randomStrobe.style.opacity = '0';
                }, 30 + Math.random() * 40);
            }
            
            // üåä CONTINUOUS MOTION BLUR - blur motion sui medi
            if (midLevel > 0.75) {
                const blurAmount = midLevel * 3;
                background.style.filter = `blur(${blurAmount}px)`;
                motionBlurActive = true;
            } else if (motionBlurActive) {
                background.style.filter = 'blur(0)';
                motionBlurActive = false;
            }
            
            // üé≤ RANDOM MICRO MOVEMENTS - movimenti sottili costanti
            if (Math.random() > 0.95) {
                const microX = (Math.random() - 0.5) * 3;
                const microY = (Math.random() - 0.5) * 3;
                const microRotate = (Math.random() - 0.5) * 1;
                background.style.transform = `scale(${zoomIntensity}) rotate(${rotateAmount + microRotate}deg) translate(${microX}px, ${microY}px)`;
            }
            
            // üéØ EFFETTO 3D POV COMPLETO - dondolio su tutti gli assi CON EASING
            // Calcola progress con easing (0-1 ciclico ogni 2 secondi)
            const cycleTime = 2000; // 2 secondi per ciclo
            const rawProgress = (Date.now() % cycleTime) / cycleTime;
            const easedProgress = currentEasingFunc(rawProgress);
            
            // Sinistra/Destra (bassi): movimento orizzontale con easing
            const swayX = (Math.sin(easedProgress * Math.PI * 2) * bassLevel * 40) + (window.targetPoint.x * bassLevel * 0.5);
            
            // Avanti/Indietro (medi): movimento verticale + zoom con easing alternato
            const depthCycle = (Date.now() % 3000) / 3000; // ciclo 3 secondi
            const depthEased = easing.easeInOut(depthCycle); // sempre smooth per profondit√†
            const swayY = (Math.sin(depthEased * Math.PI * 2) * midLevel * 35) + (window.targetPoint.y * midLevel * 0.5);
            const depthZoom = Math.sin(depthEased * Math.PI * 2) * midLevel * 0.15; // oscillazione zoom per "avanti/indietro"
            
            // Rotazione testa (alti): piccole rotazioni su tutti gli assi con bounce
            const rotateCycle = (Date.now() % 2500) / 2500;
            const rotateEased = easing.bounce(rotateCycle);
            const swayRotateZ = Math.sin(rotateEased * Math.PI * 2) * trebleLevel * 4; // rotazione Z (principale)
            const swayRotateX = Math.sin(rotateEased * Math.PI * 2) * trebleLevel * 2; // tilt testa su/gi√π
            
            // Zoom burst verso target point CON EASING
            let burstOffsetX = 0, burstOffsetY = 0, burstBlur = 0;
            if (Date.now() - lastZoomBurst < 300) {
                const burstProgress = (Date.now() - lastZoomBurst) / 300; // 0 a 1
                const burstEased = easing.easeOut(burstProgress); // decelerazione rapida
                burstOffsetX = window.targetPoint.x * (1 - burstEased) * 0.5;
                burstOffsetY = window.targetPoint.y * (1 - burstEased) * 0.5;
                // Blur con easing sinusoidale per effetto pi√π organico
                burstBlur = Math.sin(burstEased * Math.PI) * 8; // blur 0‚Üí8‚Üí0
            }
            
            // Applica TUTTI i movimenti combinati
            background.style.transform = `scale(${zoomIntensity + depthZoom}) rotate(${rotateAmount + swayRotateZ}deg) rotateX(${swayRotateX}deg) translate(${swayX + burstOffsetX}px, ${swayY + burstOffsetY}px)`;
            
            // Blur durante zoom burst verso target
            if (burstBlur > 0) {
                background.style.filter = `blur(${burstBlur}px)`;
            }
            
            // üåÄ CIRCLE PULSE (centro) - MOLTO pi√π visibile con zoom burst
            // Scala diverse per mobile e desktop
            const basePulseSize = isMobile ? 80 : 150;
            const pulseMultiplier = isMobile ? 300 : 600;
            const pulseSize = basePulseSize + bassLevel * pulseMultiplier;
            const pulseBurst = (Date.now() - lastZoomBurst < 300) ? 1.5 : 1; // amplifica durante zoom burst
            circlePulse.style.width = (pulseSize * pulseBurst) + 'px';
            circlePulse.style.height = (pulseSize * pulseBurst) + 'px';
            circlePulse.style.opacity = 0.5 + bassLevel * 0.5;
            circlePulse.style.borderWidth = (Math.max(2, isMobile ? 2 : 3) + bassLevel * (isMobile ? 5 : 10)) + 'px';
            
            // Glow extra su burst
            if (pulseBurst > 1) {
                circlePulse.style.boxShadow = `
                    0 0 60px rgba(255, 255, 255, 1),
                    0 0 120px rgba(255, 255, 255, 0.8),
                    inset 0 0 60px rgba(255, 255, 255, 0.6)
                `;
            } else {
                circlePulse.style.boxShadow = `
                    0 0 30px rgba(255, 255, 255, 0.8),
                    0 0 60px rgba(255, 255, 255, 0.6),
                    inset 0 0 30px rgba(255, 255, 255, 0.4)
                `;
            }
            
            // üîä SPEAKER FLASHES (laterali) - pi√π intensi
            speakerFlashes.forEach(flash => {
                flash.style.opacity = midLevel * 1.2;
                flash.style.filter = `blur(${30 + midLevel * 50}px)`;
            });
            
            // ‚ö° ANTENNA BEAMS (centro alto) - pi√π lunghi (limitato su mobile)
            antennaBeams.forEach((beam, i) => {
                const maxHeight = isMobile ? 250 : 500;
                const height = Math.min(trebleLevel * (isMobile ? 250 : 500), maxHeight);
                beam.style.height = height + 'px';
                beam.style.opacity = trebleLevel * 1.2;
                beam.style.transform = `rotate(${(i - 1) * 20 + trebleLevel * 60}deg)`;
                beam.style.width = (isMobile ? 1 : 2 + trebleLevel * 4) + 'px';
            });
            
            // üé® VORTEX ROTATION - ruota e pulsa (OTTIMIZZATO: meno cerchi su mobile)
            vortexRotation += energy * 3;

            // Render con frequenza ridotta su mobile per performance
            let renderFrequency = isSmallMobile ? 4 : isMobile ? 2 : 1;
            if (isSlowDevice) renderFrequency += 2;
            if (Math.floor(vortexRotation) % renderFrequency === 0) {
                vortexCtx.clearRect(0, 0, vortexCanvas.width, vortexCanvas.height);
                vortexCtx.save();
                vortexCtx.translate(vortexCanvas.width / 2, vortexCanvas.height / 2);
                vortexCtx.rotate(vortexRotation * Math.PI / 180);

                // OTTIMIZZATO: meno cerchi su mobile e slow devices
                const maxRadius = isSlowDevice ? 600 : isMobile ? 800 : 1000;
                const step = isSlowDevice ? 200 : isSmallMobile ? 160 : isMobile ? 140 : 120;
                for (let r = 100; r < maxRadius; r += step) {
                    vortexCtx.strokeStyle = `rgba(255, 255, 255, ${(bassLevel * 0.6) * (1 - r / maxRadius)})`;
                    vortexCtx.lineWidth = 2 + bassLevel * 4;
                    if (!isSlowDevice) {
                        vortexCtx.shadowBlur = 15;
                        vortexCtx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                    } else {
                        vortexCtx.shadowBlur = 0;
                    }
                    vortexCtx.beginPath();
                    vortexCtx.arc(0, 0, r, 0, Math.PI * 2);
                    vortexCtx.stroke();
                }
                vortexCtx.restore();
            }
            
            // üìä FREQUENCY BARS
            const samplesPerBar = Math.floor(bufferLength / barCount);
            freqBars.forEach((bar, i) => {
                const start = i * samplesPerBar;
                const barData = dataArray.slice(start, start + samplesPerBar);
                const barLevel = barData.reduce((a, b) => a + b) / (barData.length * 255);
                bar.style.height = (10 + barLevel * 90) + 'px';
                bar.style.opacity = 0.6 + barLevel * 0.4;
            });
            
            // Update stats
            bassVal.textContent = Math.round(bassLevel * 100);
            midVal.textContent = Math.round(midLevel * 100);
            trebleVal.textContent = Math.round(trebleLevel * 100);

            // Update signal status
            const totalSignal = bassLevel + midLevel + trebleLevel;
            if (totalSignal > 0.05) {
                signalStatus.textContent = '‚úì Signal OK';
            } else {
                signalStatus.textContent = 'No signal';
            }

            // Debug: Log frequency data ogni 60 frame per verificare se c'√® segnale
            if (Math.floor(Date.now() / 1000) % 2 === 0 && Math.random() < 0.05) {
                console.log(`üéµ Frequencies - Bass: ${Math.round(bassLevel*100)}%, Mid: ${Math.round(midLevel*100)}%, Treble: ${Math.round(trebleLevel*100)}%`);
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // AUTOPLAY removed - browser blocks it
        window.addEventListener('load', () => {
            console.log('üéµ FREE UNDERGROUND TEKNO - Radio VJ System Ready');
            console.log('üëÜ Click START to begin');
            // Show controls on load
            controls.classList.remove('hidden');
        });
        
        console.log('üéµ FREE UNDERGROUND TEKNO - Radio VJ System Ready');
        console.log('‚èØÔ∏è  Click the ‚ñ∂Ô∏è START button to begin playback');
        console.log('üì± On desktop: Click ‚ò∞ menu button (top-right) to show controls');
    </script>
</body>
</html>
